<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>STAR DRIFT</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; }
    .wrap { height:100%; display:flex; align-items:center; justify-content:center; padding:12px; box-sizing:border-box; }
    canvas { background:#070a0f; border:1px solid #1b2430; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,0.35); max-width:min(92vw, 520px); max-height:92vh; width:520px; height:780px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="520" height="780"></canvas>
  </div>

<script>

(() => {
  "use strict";

  // ------------------------------------------------------------
  // Refactor pass (v50):
  // - No gameplay/spec changes intended.
  // - Removed redundant section dividers.
  // - Fixed several comments to match actual behavior.
  // ------------------------------------------------------------

  // ======================
  // Embedded Sprites
  // ======================
  const EMBEDDED_SPRITES = {
    player: "data:image/png;base64,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",
    enemy: "data:image/png;base64,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",
  };

  const sprites = {
    player: new Image(),
    enemy: new Image(),
  };

  const SPRITE_CROP = {
    player: { sx: 167, sy: 167, sw: 866, sh: 866 },
    enemy:  { sx: 128, sy: 190, sw: 769, sh: 647 },
  };

  // Asset points to upper-right; rotate back to face upward
  const PLAYER_SPRITE_ROT = -Math.PI / 4;

  const enemyTintCache = new Map();
  function getTintedEnemy(color) {
    if (enemyTintCache.has(color)) return enemyTintCache.get(color);
    const { sx, sy, sw, sh } = SPRITE_CROP.enemy;
    const c = document.createElement("canvas");
    c.width = sw; c.height = sh;
    const g = c.getContext("2d");
    g.drawImage(sprites.enemy, sx, sy, sw, sh, 0, 0, sw, sh);
    g.globalCompositeOperation = "source-in";
    g.fillStyle = color;
    g.fillRect(0, 0, sw, sh);
    enemyTintCache.set(color, c);
    return c;
  } // use provided sprite as-is

  let spritesReady = false;
  function initSprites() {
    let remaining = 2;
    const done = () => {
      remaining--;
      if (remaining <= 0) spritesReady = true;
    };
    sprites.player.onload = done;
    sprites.player.onerror = done;
    sprites.enemy.onload = done;
    sprites.enemy.onerror = done;

    sprites.player.src = EMBEDDED_SPRITES.player;
    sprites.enemy.src = EMBEDDED_SPRITES.enemy;
  }
  const GAME_TITLE = "STAR DRIFT";

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const LOGICAL_W = canvas.width;
const LOGICAL_H = canvas.height;
const W = LOGICAL_W, H = LOGICAL_H;

// ======================
// HiDPI (devicePixelRatio) canvas scaling — keeps gameplay in LOGICAL_W/H
// ======================
let DPR = 1;
let viewScaleX = 1, viewScaleY = 1;
let needsResize = true;

function applyViewTransform() {
  ctx.setTransform(viewScaleX * DPR, 0, 0, viewScaleY * DPR, 0, 0);
}

function resizeCanvasToDisplaySize() {
  if (!needsResize) return;
  needsResize = false;

  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(1, rect.width);
  const cssH = Math.max(1, rect.height);

  const targetW = Math.round(cssW * DPR);
  const targetH = Math.round(cssH * DPR);

  if (canvas.width !== targetW) canvas.width = targetW;
  if (canvas.height !== targetH) canvas.height = targetH;

  viewScaleX = cssW / LOGICAL_W;
  viewScaleY = cssH / LOGICAL_H;
}

addEventListener("resize", () => { needsResize = true; }, { passive: true });
// Run once before the first render
resizeCanvasToDisplaySize();

  // ======================
  // Input
  // ======================
  const keys = new Set();
  addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (!e.repeat) {
      // Arcade credits (Key '5', max 9)
      if (k === "5" || e.code === "Numpad5") addCredit();

      // Continue 선택
      if (state === STATE.CONTINUE) {
        if (k === "y") continueYes();
        if (k === "n") continueNo();
      }
      // Key guide
      if (k === "k") {
        if (state === STATE.TITLE) state = STATE.KEYGUIDE;
        else if (state === STATE.KEYGUIDE) state = STATE.TITLE;
        else if (state === STATE.RANKING) state = STATE.KEYGUIDE;
      }

// Ranking board
      if (k === "r") {
        if (state === STATE.TITLE) openRankingBoard("RANKING", false);
        else if (state === STATE.RANKING) state = STATE.TITLE;
        else if (state === STATE.KEYGUIDE) openRankingBoard("RANKING", false);
      }

      if (k === "enter" && state !== STATE.CONTINUE) startOrRestart();
      if (k === "p") togglePause();
      if (k === "x" || e.code === "Space") tryUltimate();
      if (k === "c" || k === "shift") tryShield();
    }
    keys.add(k);
    if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(k)) e.preventDefault();
  }, { passive:false });
  addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const lerp  = (a,b,t) => a + (b-a)*t;

  // ======================
  // Runtime Error (freeze-safe overlay)
  // ======================
  let runtimeError = null;

  // ======================
  // Audio (WebAudio SFX)
  // ======================
  const SFX = { ctx:null, enabled:true, shotGate:0 };
  function initAudio() {
    if (SFX.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    SFX.ctx = new AC();
  }
  function tone(freq, dur, vol=0.08, type="square", endFreq=null) {
    if (!SFX.ctx || !SFX.enabled) return;
    const t0 = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const g = SFX.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (endFreq !== null) osc.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), t0 + dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g); g.connect(SFX.ctx.destination);
    osc.start(t0); osc.stop(t0 + dur + 0.02);
  }
  function noise(dur, vol=0.08) {
    if (!SFX.ctx || !SFX.enabled) return;
    const t0 = SFX.ctx.currentTime;
    const bufferSize = Math.floor(SFX.ctx.sampleRate * dur);
    const buffer = SFX.ctx.createBuffer(1, bufferSize, SFX.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2 - 1) * (1 - i/bufferSize);
    const src = SFX.ctx.createBufferSource(); src.buffer = buffer;
    const g = SFX.ctx.createGain();
    g.gain.setValueAtTime(vol, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    src.connect(g); g.connect(SFX.ctx.destination);
    src.start(t0); src.stop(t0 + dur + 0.02);
  }
  function sfxPlayerShot() {
    if (!SFX.ctx || !SFX.enabled) return;
    const now = SFX.ctx.currentTime;
    if (now < SFX.shotGate) return;
    SFX.shotGate = now + 0.07;
    tone(900, 0.03, 0.05, "square", 750);
  }
  function sfxEnemyShot() { if (Math.random() < 0.35) tone(420, 0.05, 0.035, "sawtooth", 260); }
  function sfxExplosion() { noise(0.08, 0.07); tone(180, 0.09, 0.05, "triangle", 60); }
  function sfxPower()     { tone(1200, 0.07, 0.06, "square", 1600); }
  function sfxHit()       { tone(140, 0.12, 0.09, "square", 60); noise(0.05, 0.045); }
  function sfxUltimate()  { tone(220, 0.35, 0.11, "sawtooth", 40); noise(0.25, 0.085); }
  function sfxUltReady() {
    if (!SFX.ctx || !SFX.enabled) return;
    const ctx = SFX.ctx;
    const t0 = ctx.currentTime;

    // Retro arcade "ULT READY" chime: rising arpeggio + sparkle noise (audible, game-like).
    const notes = [
      { f: 523.25, t: 0.00, dur: 0.10, vol: 0.16, type: "square", end: 659.25 },   // C5 -> E5
      { f: 659.25, t: 0.09, dur: 0.11, vol: 0.15, type: "square", end: 783.99 },   // E5 -> G5
      { f: 783.99, t: 0.19, dur: 0.12, vol: 0.14, type: "square", end: 987.77 },   // G5 -> B5
      { f: 987.77, t: 0.30, dur: 0.14, vol: 0.13, type: "square", end: 1318.51 },  // B5 -> E6
    ];

    for (const n of notes) {
      const ts = t0 + n.t;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = n.type;
      osc.frequency.setValueAtTime(n.f, ts);
      if (n.end !== null) osc.frequency.exponentialRampToValueAtTime(Math.max(20, n.end), ts + n.dur);
      g.gain.setValueAtTime(0.0001, ts);
      g.gain.exponentialRampToValueAtTime(n.vol, ts + 0.008);
      g.gain.exponentialRampToValueAtTime(0.0001, ts + n.dur);
      osc.connect(g); g.connect(ctx.destination);
      osc.start(ts); osc.stop(ts + n.dur + 0.02);
    }

    // Timing anchor for the sparkle tail (ping chord removed).
    const chordT = t0 + 0.46;

    // Tiny sparkle noise tail so it cuts through.
    const ndur = 0.10;
    const bufferSize = Math.floor(ctx.sampleRate * ndur);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0; i<bufferSize; i++) {
      const fade = 1 - i / bufferSize;
      data[i] = (Math.random() * 2 - 1) * fade;
    }
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    const ng = ctx.createGain();
    ng.gain.setValueAtTime(0.06, chordT - 0.02);
    ng.gain.exponentialRampToValueAtTime(0.0001, chordT - 0.02 + ndur);
    src.connect(ng); ng.connect(ctx.destination);
    src.start(chordT - 0.02);
    src.stop(chordT - 0.02 + ndur + 0.02);
  }
  function sfxWarning()   { tone(260, 0.10, 0.05, "square", 520); }
  function sfxShield()    { tone(520, 0.12, 0.07, "triangle", 980); }

  function sfxCoin()      { tone(980, 0.06, 0.06, "square", 1480); tone(1480, 0.06, 0.05, "square", 1960); }
  function sfxNoCredit() { tone(90, 0.12, 0.10, "square", 18); noise(0.06, 0.060); }


  function addCredit() {
    initAudio();
    if (credits >= 9) return;
    credits += 1;
    sfxCoin();
  }

  function enterContinue() {
    if (state === STATE.CONTINUE) return;
    continueCountdown = 5.0;
    state = STATE.CONTINUE;
  }

  function continueYes() {
    if (state !== STATE.CONTINUE) return;

    // If no credit, you can't continue. Give a chance to insert credit.
    if (credits <= 0) {
      noCreditMsg = 1.0;
      sfxNoCredit();
      triggerShake(6, 1.0);
      return;
    }

    credits -= 1;

    // restore lives
    player.lives = 3;

    // refill shield (ultimate gauge preserved on continue)
    player.shieldCharges = 3;

    state = STATE.PLAY;
  }

  function continueNo() {
    if (state !== STATE.CONTINUE) return;
    openRankingBoard("GAME OVER", true);
  }

  // ======================
  // Game State
  // ======================
  const STATE = {
    TITLE: "TITLE",
    PLAY: "PLAY",
    ROUND_CLEAR: "ROUND_CLEAR",
    CONTINUE: "CONTINUE",
    GAME_OVER: "GAME_OVER",
    VICTORY: "VICTORY",
    PAUSE: "PAUSE",
    RANKING: "RANKING",
    KEYGUIDE: "KEYGUIDE",
  };
  let state = STATE.TITLE;
  let prevState = state;

  // Entities
  let bullets = [];
  let enemies = [];
  let enemyBullets = [];
  let powerups = [];
  let hazards = [];
  let particles = [];
  let boss = null;

  // Ultimate / Shield
  let nuke = null;   // close -> far
  let shield = null; // constant accel upward

  // Progress
  let roundIndex = 0;
  let roundTime = 0;
  let roundSchedule = [];
  let schedulePtr = 0;
  let bossSpawned = false;
  let bossSpawnAt = null;
  const BOSS_SPAWN_DELAY = 2.0; // after last wave cleared
  const YELLOW_TANK_UNDER_BOSS_Y_OFFSET = 62; // keep yellow tank a bit lower so its HP bar doesn't get covered by the boss

  // Round balance table (centralized tuning; preserves current behavior)
  const ENEMY_HP_BASE_SCALE = 0.70;
  const ROUND_BALANCE = [
    { enemyHpMult: 1.00, enemyBulletMult: 1.00, enemyFireCdMult: 1.00,
      bulletSpeed: { scout:195, shooter:210, zigzag:205, tank:210, carrier:210 } },
    { enemyHpMult: 2.00, enemyBulletMult: 1.08, enemyFireCdMult: 0.90,
      bulletSpeed: { scout:210, shooter:230, zigzag:230, tank:230, carrier:230 } },
    { enemyHpMult: 2.80, enemyBulletMult: 1.16, enemyFireCdMult: 0.85,
      bulletSpeed: { scout:225, shooter:250, zigzag:250, tank:245, carrier:245 } },
  ];
  function getRoundBalance(r=roundIndex){ return ROUND_BALANCE[r] ?? ROUND_BALANCE[0]; }

  // Ultimate gauge: fills when you keep hitting enemies (no weapon/power scaling)
  const ULT_FILL_SECONDS = 0.45; // v7: 1/3 charge speed vs v6 (3x slower)



  // FX
  let bgY = 0;
  const flash = { t: 0 };
  const shake = { t: 0, mag: 0, dur: 1.0 };

  const nukeFx = { t: 0, dur: 0.55 }; // screen-wide ultimate impact FX

  function triggerNukeFx() { nukeFx.t = nukeFx.dur; }

  function triggerShake(mag=6, dur=1.0) {
    shake.mag = mag;
    shake.dur = dur;
    shake.t = dur; // refresh (not additive)
  }


  // Score
  let score = 0;


  // Total hits taken (for scoreboard/leaderboard)
  let hitsTaken = 0;

  // Arcade credits (0..9)
  let credits = 0;
  let continueCountdown = 0;
  let noCreditMsg = 0; // seconds

  // ======================
  // Ranking (Top 10, score + hits) - LocalStorage
  // ======================
  const LB_KEY = "neon_strikers_leaderboard_v1";
  let rankingHeader = "RANKING";
  let lastRunScore = 0;
  let lastRunHits  = 0;
  let lastRunTs    = 0;
  let leaderboardCache = [];

  function loadLeaderboard() {
    try {
      const raw = localStorage.getItem(LB_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      if (!Array.isArray(arr)) return [];
      return arr
        .filter(e => e && Number.isFinite(e.score) && Number.isFinite(e.hits))
        .map(e => ({ score: Math.max(0, e.score|0), hits: Math.max(0, e.hits|0), ts: Number.isFinite(e.ts) ? e.ts : 0 }))
        .slice(0, 10);
    } catch (e) {
      return [];
    }
  }

  function saveLeaderboard(arr) {
    try { localStorage.setItem(LB_KEY, JSON.stringify(arr)); } catch (e) {}
  }

  function recordAndGetLeaderboard(s, h, ts) {
    const arr = loadLeaderboard();
    const tsv = Number.isFinite(ts) ? ts : Date.now();
    arr.push({ score: Math.max(0, s|0), hits: Math.max(0, h|0), ts: tsv });
    arr.sort((a,b) => (b.score - a.score) || (a.hits - b.hits) || (a.ts - b.ts));
    const top = arr.slice(0, 10);
    saveLeaderboard(top);
    return top;
  }

  function openRankingBoard(header, recordRun) {
    rankingHeader = header || "RANKING";
    if (recordRun) {
      lastRunScore = score|0;
      lastRunHits  = hitsTaken|0;
      lastRunTs    = Date.now();
      leaderboardCache = recordAndGetLeaderboard(lastRunScore, lastRunHits, lastRunTs);
    } else {
      leaderboardCache = loadLeaderboard();
    }
    state = STATE.RANKING;
  }


  // Player
  const player = {
    x: W/2,
    y: H*0.80,
    r: 22.5,
    hitR: 22.5, // matches full sprite footprint (wings included)
    speed: 350,
    lives: 3,
    invuln: 0,
    invulnMode: "none", // "none"|"hit"|"ultimate"
    weapon: 1,          // 1..4 (max 4)
    power: 0,           // 0..6 (max 6)
    ult: 0,
    ultGauge: 0,
    shieldCharges: 3,
    fireCd: 0,
  };

  // Power 0 → Lv1
  // Power 1~2 → Lv2
  // Power 3~4 → Lv3
  // Power 5~6 → Lv4
  function weaponFromPower(p) {
    if (p >= 5) return 4;
    if (p >= 3) return 3;
    if (p >= 1) return 2;
    return 1;
  }

  function resetAll() {
    bullets = [];
    enemies = [];
    enemyBullets = [];
    powerups = [];
    hazards = [];
    particles = [];
    boss = null;
    nuke = null;
    shield = null;

    score = 0;
    hitsTaken = 0;


    player.x = W/2;
    player.y = H*0.80;
    player.lives = 3;
    player.invuln = 0;
    player.invulnMode = "none";
    player.weapon = 1;
    player.power = 0;
    player.ult = 0;
    player.ultGauge = 0;
    player.shieldCharges = 3;
    player.fireCd = 0;
    player.hitR = player.r;

    roundIndex = 0;
    roundTime = 0;
    schedulePtr = 0;
    bossSpawned = false;
    buildSchedule(roundIndex);

    flash.t = 0;
    shake.t = 0; shake.mag = 0;

    runtimeError = null;
  }

  function startOrRestart() {
    if (state === STATE.PLAY || state === STATE.PAUSE || state === STATE.CONTINUE) return;
    initAudio();

    // Starting/restarting always costs 1 credit
    if (credits <= 0) {
      noCreditMsg = 1.0;
      sfxNoCredit();
      triggerShake(6, 1.0);
      return;
    }

    credits -= 1;
    resetAll();
    state = STATE.PLAY;
  }

  function togglePause() {
    if (state === STATE.PLAY) { prevState = state; state = STATE.PAUSE; }
    else if (state === STATE.PAUSE) { state = prevState || STATE.PLAY; }
  }

  // ======================
  // Schedule
  // ======================
// Round scheduling (data-driven)
// ======================
const S = (t, fn) => [t, fn];

const ROUND_DEFS = [
  {
    name: "Round 1",
    events: [
      S(0.8,  () => spawnLine("scout", 6, 70, 1.05)),
      S(2.3,  () => spawnV("scout", 6, 1.05)),
      S(4.0,  () => spawnPairShooters(false)),
      S(6.3,  () => spawnZigzagPack(5, 1.05)),
      S(9.2,  () => spawnCarrier(0.55)),
      S(12.2, () => spawnLine("scout", 8, 60, 1.10)),
      S(14.8, () => spawnPairShooters(false)),
      S(15.8, () => spawnZigzagPack(5, 1.06)),
      S(18.5, () => spawnLine("scout", 6, 58, 1.12)),
      S(17.6, () => spawnZigzagPack(6, 1.08)),
      S(20.5, () => spawnCarrier(0.30)),
      S(23.0, () => spawnPairShooters(false)), // last spawn @ 23s
    ],
  },
  {
    name: "Round 2",
    events: [
      S(0.8,  () => spawnLine("scout", 8, 60, 1.15)),
      S(2.6,  () => spawnPairShooters(true)),
      S(5.4,  () => spawnZigzagPack(8, 1.12)),
      S(10.7, () => spawnCarrier(0.65)),
      S(13.0, () => spawnLine("scout", 10, 54, 1.18)),
      // Mid-round spike waves
      S(15.6, () => spawnZigzagPack(6, 1.15)),
      S(18.0, () => spawnPairShooters(true)),
      S(20.2, () => spawnLine("scout", 6, 56, 1.20)),
      S(16.5, () => spawnTank(0.70)),
      S(23.3, () => spawnCarrier(0.30)),
      S(24.8, () => spawnPairShooters(false)),
      S(27.0, () => spawnLine("scout", 8, 52, 1.22)), // last spawn @ 27s
    ],
  },
  {
    // Round 3+
    name: "Round 3+",
    events: [
      S(0.8,  () => spawnLine("scout", 12, 50, 1.22)),
      S(2.5,  () => spawnPairShooters(true)),
      S(4.8,  () => spawnLine("scout", 14, 46, 1.24)),
      S(7.0,  () => spawnZigzagPack(12, 1.18)),
      S(11.8, () => spawnCarrier(0.60)),
      S(14.0, () => spawnPairShooters(true)),
      S(16.5, () => spawnZigzagPack(14, 1.20)),
      S(19.2, () => spawnLine("scout", 16, 42, 1.28)),
      S(24.0, () => spawnCarrier(0.30)),
      S(19.5, () => spawnTank(0.50)),
      S(26.5, () => spawnPairShooters(true)),
      // Extend waves so last spawn is at 32s (as specified)
      S(28.5, () => spawnZigzagPack(16, 1.22)),
      S(32.0, () => spawnLine("scout", 18, 40, 1.30)), // last spawn @ 32s
    ],
  },
];

function getRoundDef(r) {
  return ROUND_DEFS[Math.min(r, ROUND_DEFS.length - 1)];
}

function buildSchedule(r) {
  roundSchedule = [];
  schedulePtr = 0;
  bossSpawned = false;
  bossSpawnAt = null;
  roundTime = 0;

  const add = (t, fn) => roundSchedule.push({ t, fn });

  const def = getRoundDef(r);
  for (const [t, fn] of def.events) add(t, fn);

  // Preserve original behavior (stable ordering by time)
  roundSchedule.sort((a,b) => a.t - b.t);
}
// ======================
  // Enemies
  // ======================

  // Enemy base stats (HP scaled per round in makeEnemy)
  const EnemyBase = {
    scout:  { hp: 8,   r: 20, speed: 165, points: 20 },
    shooter:{ hp: 12,  r: 22.5, speed: 115, points: 35 },
    zigzag: { hp: 11,  r: 21.25, speed: 135, points: 30 },
    tank:   { hp: 26,  r: 30, speed: 80,  points: 70 },
    carrier:{ hp: 16,  r: 25, speed: 100, points: 55 },
  };

  // Yellow heavy unit (tank) spec
  // - Spawns from Round 2+
  // - Round-based HP (R2: 5 ultimates, R3: 7 ultimates)
  const YELLOW_TANK_ULT_DMG = 220;
  // Round-based tank HP:
  // - Round 2: takes 5 ultimates
  // - Round 3: takes 7 ultimates
  function getYellowTankHP(r=roundIndex){
    // Round 2 (roundIndex=1): 5 ultimates
    // Round 3 (roundIndex=2): 7 ultimates
    const ultHits = (r === 1) ? 5 : (r === 2) ? 7 : 3;
    return YELLOW_TANK_ULT_DMG * ultHits;
  }

  function getEnemyBase(type) {
    return EnemyBase[type];
  }

  function makeEnemy(type, x, y, extra={}) {
    const base = getEnemyBase(type);
    const rb = getRoundBalance();

    x = clamp(x, base.r + 6, W - (base.r + 6));
    // Round-based HP scaling (normal enemies)
    // Yellow tank uses fixed HP.
    let hp;
    if (type === "tank") {
      hp = Math.ceil((extra.hp ?? getYellowTankHP(roundIndex)));
    } else {
      hp = Math.ceil(base.hp * rb.enemyHpMult * ENEMY_HP_BASE_SCALE * (extra.hpMult ?? 1));
    }

    const baseCd = ({
      scout: 2.00,
      shooter: 1.55,
      zigzag: 1.75,
      tank: 2.20,
      carrier: 2.30,
    })[type] ?? 2.0;

    // keep existing round cadence tuning
    const cdMult = rb.enemyFireCdMult;

    // Drop rule:
    // - carrier drops supply 100%
    // - other units drop 0%
    const dropPower = (type === "carrier") ? 1.0 : 0.0;

    return {
      type,
      x, y,
      vx: extra.vx ?? 0,
      vy: extra.vy ?? base.speed,
      r: base.r,
      hitR: (type === "tank") ? (base.r * 1.08) : base.r,
      hp,
      hpMax: hp,
      t: 0,
      shootCd: extra.shootCd ?? rand(0.45, 1.05),
      baseCd: baseCd * cdMult,
      points: base.points,
      zigAmp: extra.zigAmp ?? 55,
      zigFreq: extra.zigFreq ?? 2.1,
      stopY: extra.stopY ?? rand(H*0.14, H*0.24),
      lockY: extra.lockY ?? null,
      targetY: extra.targetY ?? null,
      entryDone: extra.entryDone ?? false,
      patrolVx: extra.patrolVx ?? null,
      entryVy: extra.entryVy ?? null,
      dropPower,
      facing: Math.PI/2, // toward player each frame
    };
  }


  function spawnLine(type, n, gap, speedMult=1.0) {
    const base = getEnemyBase(type);
    const r = (base?.r ?? 18);
    const side = Math.max(40, r + 10);

    let effGap = gap;
    let totalW = (n-1)*effGap;
    const maxSpan = W - 2*side;

    // If the formation would overflow the screen, compress the gap so every unit stays on-screen.
    if (n > 1 && totalW > maxSpan) {
      effGap = maxSpan / (n-1);
      totalW = (n-1)*effGap;
    }

    const startX = clamp((W - totalW)/2, side, W - side - totalW);
    for (let i=0;i<n;i++){
      enemies.push(makeEnemy(type, startX + i*effGap, -30 - i*10, {
          vy: (base?.speed ?? 120) * speedMult,
      }));
    }
  }

  function spawnV(type, n, speedMult=1.0) {
    const base = getEnemyBase(type);
    const mid = W/2;
    const spread = 28;
    for (let i=0;i<n;i++){
      const x = mid + (i - (n-1)/2)*spread;
      enemies.push(makeEnemy(type, x, -40 - i*18, { vy: (base.speed)*speedMult }));
    }
  }


  function spawnPairShooters(denser=false) {
    const left = W*0.28, right = W*0.72;
    enemies.push(makeEnemy("shooter", left,  -30, { stopY: denser ? H*0.18 : H*0.22 }));
    enemies.push(makeEnemy("shooter", right, -70, { stopY: denser ? H*0.18 : H*0.24 }));
    if (denser) enemies.push(makeEnemy("shooter", W*0.50, -110, { stopY: H*0.20 }));
  }


  function spawnZigzagPack(n, speedMult=1.0) {
    const base = getEnemyBase("zigzag");
    for (let i=0;i<n;i++){
      const x = rand(70, W-70);
      enemies.push(makeEnemy("zigzag", x, -40 - i*22, {
          vy: base.speed * speedMult,
        zigAmp: 55,
        zigFreq: 2.1
      }));
    }
  }


  function spawnTank(xFrac=0.5) {
    // Yellow heavy unit: enters from the top, then patrols horizontally at a fixed Y (right under the boss area).
    const base = getEnemyBase("tank");

    // Boss anchor estimate (boss may not be spawned yet during the wave).
    const estBossY = (roundIndex === 1) ? H*0.16 : H*0.14;
    const estBossH = (roundIndex === 1) ? 160 : 190;

    // Fixed target under the boss (no teleporting when the boss appears).
    let yTarget = estBossY + estBossH/2 + base.r + YELLOW_TANK_UNDER_BOSS_Y_OFFSET;
    yTarget = clamp(yTarget, 80, H - 140);

    // Spawn above the screen, then descend to yTarget.
    const spawnY = -base.r - 40;

    const dir = (Math.random() < 0.5) ? -1 : 1;
    const patrolVx = dir * (roundIndex === 0 ? 140 : (roundIndex === 1 ? 155 : 170));
    const entryVy = 170;

    enemies.push(makeEnemy("tank", W*xFrac, spawnY, { hp: getYellowTankHP(roundIndex),
      vx: 0,
      vy: entryVy,
      targetY: yTarget,
      entryDone: false,
      patrolVx,
      entryVy,
    }));
  }


  function spawnCarrier(xFrac=0.5) {
    const base = getEnemyBase("carrier");
    enemies.push(makeEnemy("carrier", W*xFrac, -50, { vy: base.speed }));
  }


  // ======================
  // Aim helpers
  // ======================
  function aimVec(fromX, fromY, speed) {
    let dx = player.x - fromX;
    let dy = player.y - fromY;
    dy = Math.max(dy, 20);
    const len = Math.hypot(dx, dy) || 1;
    return { vx: dx/len * speed, vy: dy/len * speed };
  }

  function spreadAimed(fromX, fromY, count, speed, spreadDeg, src="enemy") {
    let dx = player.x - fromX;
    let dy = player.y - fromY;
    dy = Math.max(dy, 20);
    const base = Math.atan2(dy, dx);

    const m = getRoundBalance().enemyBulletMult ?? 1;
    const s = speed * m;
    const half = (count-1)/2;
    const spreadScale = (player.hitR || player.r) / 18;
    const step = (spreadDeg * spreadScale) * Math.PI/180;

    for (let i=0;i<count;i++){
      const ang = base + (i-half) * step;
      pushEnemyBullet(fromX, fromY, Math.cos(ang)*s, Math.sin(ang)*s, 6, src);
    }
  }

  // ======================
  // Bullets / Hazards
  // ======================
  function pushEnemyBullet(x, y, vx, vy, r=6, src="enemy") {
    if (vy < 40) vy = 40;
    enemyBullets.push({ x, y, vx, vy, r, src });
    sfxEnemyShot();
  }

  function spawnScreenWipe(telegraph=3.0, fire=0.55) {
    const mode = (Math.random() < 0.5) ? "vertical" : "horizontal";
    if (mode === "vertical") {
      const safeW = 80;
      const safeX = rand(80, W-80);
      hazards.push({ kind:"wipe", mode, safeX, safeW, state:"telegraph", t:0, telegraph, fire });
    } else {
      const safeH = 80;
      const safeY = rand(H*0.45, H*0.88);
      hazards.push({ kind:"wipe", mode, safeY, safeH, state:"telegraph", t:0, telegraph, fire });
    }
    sfxWarning();
  }

  function spawnBossLaser(telegraph=3.0, countOverride=null) {
    // Laser: show path for 3s (tracks player for most of it), then instant fire.
    // Must originate from boss. Beam count is controlled per-round.
    if (!(boss && boss.alive && boss.entryDone)) return;

    const count = (countOverride === 1 || countOverride === 2)
      ? countOverride
      : ((Math.random() < 0.55) ? 1 : 2);

    const baseY = boss.y + boss.h * 0.32;
    const offsets = (count === 2) ? [-boss.w * 0.18, boss.w * 0.18] : [0];

    for (let i = 0; i < offsets.length; i++) {
      const off = offsets[i];
      const ox = boss.x + off;

      // initial angle; will track player for most of the telegraph in hazard update
      const tx = rand(40, W - 40);
      const ty = rand(H * 0.55, H * 0.92);
      const ang = Math.atan2(ty - baseY, tx - ox);

      hazards.push({
        kind: "laser",
        from: "boss",
        mOff: off,
        ang,
        len: 1400,
        width: 10,
        state: "telegraph",
        t: 0,
        lockX: null,
        lockY: null,
        telegraph,
        fire: 0.20
      });
    }
  }

  // ======================
  // Player shooting (muzzles reflect weapon level)
  // ======================
  function getMuzzlesForWeapon(level) {
    // Scale muzzle offsets with the ship so bullets still originate from the correct place when player size changes.
    const k = player.r / 18;
    const yNose = player.y - (22 * k);
    const dxNose = 7 * k;
    const dxSide = 22 * k;
    const ySide = player.y - (6 * k);

    // Lv1: center 1 stream
    // Lv2: 2 nose muzzles (L/R)
    // Lv3: + right equipment
    // Lv4: + left equipment
    if (level === 1) return [{ x: player.x, y: yNose }];
    if (level === 2) return [
      { x: player.x - dxNose, y: yNose },
      { x: player.x + dxNose, y: yNose },
    ];
    if (level === 3) return [
      { x: player.x - dxNose, y: yNose },
      { x: player.x + dxNose, y: yNose },
      { x: player.x + dxSide, y: ySide },
    ];
    return [
      { x: player.x - dxNose, y: yNose },
      { x: player.x + dxNose, y: yNose },
      { x: player.x + dxSide, y: ySide },
      { x: player.x - dxSide, y: ySide },
    ];
  }


  function shootPlayer() {
    const dmg = 2 + 0.5 * player.power;
    const speed = 650;

    const muzzles = getMuzzlesForWeapon(player.weapon);
    for (const m of muzzles) {
      // straight up (parallel streams), consistent with "줄기"
      const ang = (-90) * Math.PI/180;
      bullets.push({ x: m.x, y: m.y, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, r: 4, dmg });
    }
    sfxPlayerShot();
  }

  // ======================
  // Ultimate: close -> far (bigger near you, then recede)
  // ======================
  function tryUltimate() {
    if (state !== STATE.PLAY) return;
    if (player.ult <= 0) return;
    if (nuke) return;

    player.ult = 0;
    player.ultGauge = 0;

    player.invuln = Math.max(player.invuln, 2.0);
    player.invulnMode = "ultimate";

const startX = player.x;
const startY = clamp(player.y - 30, 80, H - 140);
const endX   = W * 0.5;
const endY   = H * 0.5;
const dur    = 0.75;

nuke = {
  state: "recede",
  x: startX,
  y: startY,
  startX, startY,
  endX, endY,
  t: 0, dur,
  u: 0,

  startScale: 1.95,
  endScale:   0.28,
  scale:      1.95,

  impactX: endX,
  impactY: endY
};

    sfxUltimate();
    flash.t = 0.10;
    // (shake removed per spec)
  }

  function maybeDropSupplyForEnemy(e) {
    // Prevent duplicate drops from the same enemy (e.g., multiple bullets hitting on the death frame)
    if (e._dropDone) return;
    e._dropDone = true;
    if (Math.random() < e.dropPower) {
      powerups.push({ x:e.x, y:e.y, r:12, vy:120, t:0, kind:"power" });
    }
  }

  function applyNukeImpact() {
    // 궁극기 킬도 "탄환 킬과 동일한 드롭 공식" 적용
    // (현재 규칙상 carrier=100%, 나머지=0%)
    const survivors = [];
    for (const e of enemies) {
      if (e.type === "tank") {
        e.hp -= YELLOW_TANK_ULT_DMG;
        popParticles(e.x, e.y, 18);
        if (e.hp <= 0) {
          score += e.points;
          maybeDropSupplyForEnemy(e);
          popParticles(e.x, e.y, 22);
        } else {
          survivors.push(e);
        }
      } else {
        score += e.points;
        maybeDropSupplyForEnemy(e);
        popParticles(e.x, e.y, 14);
      }
    }
    enemies = survivors;

    const bossAlive = (boss && boss.alive && boss.entryDone);

    // 일반 유닛 탄환은 제거. (보스가 존재할 때는 보스 발사 탄환/패턴은 유지)
    if (bossAlive) {
      enemyBullets = enemyBullets.filter(eb => eb.src === "boss");
      // hazards keep (boss patterns must not be canceled)
    } else {
      enemyBullets = [];
      hazards = [];
    }

    shield = null;

    // boss fixed damage
    if (bossAlive) {
      boss.hp -= 220;
      if (boss.hp < 0) boss.hp = 0;
    }


    // Nuke impact FX (global strike feel: main burst + brief screen flash)
    triggerNukeFx();

    const cx = nuke ? nuke.impactX : W/2;
    const cy = nuke ? nuke.impactY : (H * 0.18);

    // main burst (origin) - kept like v21
    for (let i=0;i<90;i++){
      particles.push({ x: cx, y: cy, vx: rand(-520, 520), vy: rand(-520, 520), t:0, life: rand(0.30, 0.85) });
    }

    // very light, screen-wide sparks so it still reads as a full-range attack (toned down vs v22)
    for (let b=0;b<2;b++){
      const bx = rand(70, W - 70);
      const by = rand(H * 0.28, H * 0.85);
      for (let i=0;i<8;i++){
        particles.push({ x: bx, y: by, vx: rand(-220, 220), vy: rand(-220, 220), t:0, life: rand(0.18, 0.40) });
      }
    }

    // slightly stronger shake than v21, but not overwhelming
    triggerShake(9, 0.60);

    flash.t = 0.20;
    sfxExplosion(); sfxExplosion();
  }

  // ======================
  // Shield: constant acceleration upward
  // ======================
  function tryShield() {
    if (state !== STATE.PLAY) return;
    if (player.shieldCharges <= 0) return;
    if (shield) return;

    player.shieldCharges -= 1;

    shield = {
      y: clamp(player.y - 60, 60, H - 120),
      vy: -120,
      ay: -420,
      h: 28
    };

    sfxShield();
    flash.t = 0.06;
  }

  // ======================
  // Bosses
  // ======================
  function spawnBoss(round) {
    if (boss) return;
    boss = (round === 0) ? makeBoss1() : (round === 1) ? makeBoss2() : makeBoss3();
  }

  function makeBossBase(name, hp, w, h, variant) {
    return { name, variant, x: W/2, y: -h, w, h, hp, hpMax: hp, t: 0, phase: 1, alive: true, entryDone: false, vx: 120, atkTimer: 0, wipeCd: 6.0, laserCd: 8.0 };
  }

  function makeBoss1() {
    const b = makeBossBase("Iron Mantis", 1360, 220, 140, 1);
    b.pattern = (dt) => {
      b.t += dt;
      if (!b.entryDone) {
        b.y += 150 * dt;
        if (b.y >= H*0.18) { b.y = H*0.18; b.entryDone = true; b.atkTimer = 0.9; b.wipeCd = 5.0; b.laserCd = 8.5; }
        return;
      }
      b.x += b.vx * dt;
      if (b.x < b.w/2 + 20) { b.x = b.w/2 + 20; b.vx *= -1; }
      if (b.x > W - (b.w/2 + 20)) { b.x = W - (b.w/2 + 20); b.vx *= -1; }

      const r = b.hp / b.hpMax;
      b.phase = (r > 0.60) ? 1 : 2;

      b.wipeCd -= dt;
      if (b.wipeCd <= 0) { spawnScreenWipe(3.0, 0.55); b.wipeCd = (b.phase === 1) ? 8.0 : 7.0; }


      b.atkTimer -= dt;
      if (b.atkTimer <= 0) {
        if (b.phase === 1) { spreadAimed(b.x, b.y + 60, 5, 210, 7, "boss"); b.atkTimer = 0.95; }
        else { spreadAimed(b.x, b.y + 60, 7, 235, 8, "boss"); spreadAimed(b.x, b.y + 60, 3, 260, 12, "boss"); b.atkTimer = 0.85; }
      }
    };
    return b;
  }

  function makeBoss2() {
    const b = makeBossBase("Storm Railgun", 3600, 260, 160, 2);
    b.vx = 135;
    b.pattern = (dt) => {
      b.t += dt;
      if (!b.entryDone) {
        b.y += 160 * dt;
        if (b.y >= H*0.16) { b.y = H*0.16; b.entryDone = true; b.atkTimer = 0.95; b.wipeCd = 5.5; b.laserCd = 8.0; }
        return;
      }

      b.x += b.vx * dt;
      if (b.x < b.w/2 + 10) { b.x = b.w/2 + 10; b.vx *= -1; }
      if (b.x > W - (b.w/2 + 10)) { b.x = W - (b.w/2 + 10); b.vx *= -1; }

      const r = b.hp / b.hpMax;
      b.phase = (r > 0.70) ? 1 : (r > 0.35 ? 2 : 3);

      b.wipeCd -= dt;
      if (b.wipeCd <= 0) { spawnScreenWipe(3.0, 0.55); b.wipeCd = (b.phase === 1) ? 8.0 : (b.phase === 2 ? 7.0 : 6.0); }

      b.laserCd -= dt;
      if (b.laserCd <= 0) { spawnBossLaser(3.0, 1); b.laserCd = (b.phase === 1) ? 8.5 : (b.phase === 2 ? 8.0 : 7.5); }

      b.atkTimer -= dt;
      if (b.atkTimer <= 0) {
        if (b.phase === 1) { spreadAimed(b.x, b.y + 70, 6, 230, 7, "boss"); b.atkTimer = 0.95; }
        else if (b.phase === 2) { spreadAimed(b.x, b.y + 70, 8, 250, 8, "boss"); b.atkTimer = 0.90; }
        else { spreadAimed(b.x, b.y + 70, 10, 265, 8, "boss"); spreadAimed(b.x, b.y + 70, 3, 295, 14, "boss"); b.atkTimer = 0.85; }
      }
    };
    return b;
  }

  function makeBoss3() {
    const b = makeBossBase("Abyss Fortress", 7200, 300, 190, 3);
    b.vx = 150;
    b.pattern = (dt) => {
      b.t += dt;
      if (!b.entryDone) {
        b.y += 180 * dt;
        if (b.y >= H*0.14) { b.y = H*0.14; b.entryDone = true; b.atkTimer = 0.95; b.wipeCd = 5.0; b.laserCd = 7.5; }
        return;
      }

      b.x += b.vx * dt;
      if (b.x < b.w/2 + 8) { b.x = b.w/2 + 8; b.vx *= -1; }
      if (b.x > W - (b.w/2 + 8)) { b.x = W - (b.w/2 + 8); b.vx *= -1; }

      const r = b.hp / b.hpMax;
      b.phase = (r > 0.75) ? 1 : (r > 0.45 ? 2 : (r > 0.15 ? 3 : 4));

      b.wipeCd -= dt;
      if (b.wipeCd <= 0) { spawnScreenWipe(3.0, 0.60); b.wipeCd = (b.phase <= 2) ? 7.0 : (b.phase === 3 ? 6.0 : 5.0); }

      b.laserCd -= dt;
      if (b.laserCd <= 0) { spawnBossLaser(3.0, 2); b.laserCd = (b.phase <= 2) ? 8.0 : (b.phase === 3 ? 7.5 : 7.0); }

      b.atkTimer -= dt;
      if (b.atkTimer <= 0) {
        if (b.phase === 1) { spreadAimed(b.x, b.y + 80, 10, 250, 7, "boss"); b.atkTimer = 0.95; }
        else if (b.phase === 2) { spreadAimed(b.x, b.y + 80, 12, 265, 7, "boss"); spreadAimed(b.x, b.y + 80, 3, 300, 14, "boss"); b.atkTimer = 0.90; }
        else if (b.phase === 3) { spreadAimed(b.x, b.y + 80, 14, 280, 7, "boss"); spreadAimed(b.x, b.y + 80, 5, 320, 12, "boss"); b.atkTimer = 0.85; }
        else { spreadAimed(b.x, b.y + 80, 16, 295, 7, "boss"); spreadAimed(b.x, b.y + 80, 5, 340, 12, "boss"); b.atkTimer = 0.80; }
      }
    };
    return b;
  }

  // ======================
  // Collisions
  // ======================
  function circleHit(ax, ay, ar, bx, by, br) {
    const dx = ax-bx, dy = ay-by;
    return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
  }
  function rectCircleHit(rx, ry, rw, rh, cx, cy, cr) {
    const px = clamp(cx, rx, rx+rw);
    const py = clamp(cy, ry, ry+rh);
    const dx = cx - px, dy = cy - py;
    return dx*dx + dy*dy <= cr*cr;
  }

  function distPointToSegment(px, py, x0, y0, x1, y1) {
    const vx = x1 - x0, vy = y1 - y0;
    const wx = px - x0, wy = py - y0;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px - x0, py - y0);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px - x1, py - y1);
    const b = c1 / c2;
    const bx = x0 + b*vx, by = y0 + b*vy;
    return Math.hypot(px - bx, py - by);
  }


  // ======================
  // Update loop (freeze-safe)
  // ======================
  let last = performance.now();
  const MAX_FRAME_DT = 0.033;
  const CLAMP_SUBSTEPS = 2;
  function tick(now) {
    requestAnimationFrame(tick);

const rawDt = (now - last) / 1000;
const dt = Math.min(MAX_FRAME_DT, rawDt);
    last = now;

    try {
      if (!runtimeError) {
        // common timers (must tick even on TITLE/GAME_OVER so effects don't get stuck)
        if (flash.t > 0) flash.t = Math.max(0, flash.t - dt);
        if (shake.t > 0) shake.t = Math.max(0, shake.t - dt);
        if (nukeFx.t > 0) nukeFx.t = Math.max(0, nukeFx.t - dt);
        if (noCreditMsg > 0) noCreditMsg = Math.max(0, noCreditMsg - dt);

if (state === STATE.PLAY) {
  // If we had to clamp dt, sub-step to improve stability while keeping total simulated time identical (dt).
  if (rawDt > MAX_FRAME_DT) {
    const subDt = dt / CLAMP_SUBSTEPS;
    for (let i = 0; i < CLAMP_SUBSTEPS; i++) update(subDt);
  } else {
    update(dt);
  }
}
        else if (state === STATE.CONTINUE) updateContinue(dt);
      }
      render();
    } catch (err) {
      runtimeError = (err && err.stack) ? err.stack : String(err);
    }
  }


  // ======================
  // Update helpers (v32 refactor)
  // ======================
  function updateBackground(dt) {
    bgY += 140 * dt;
    if (bgY > H) bgY -= H;
  }

  function advanceRoundSchedule(dt) {
    roundTime += dt;
    while (schedulePtr < roundSchedule.length && roundTime >= roundSchedule[schedulePtr].t) {
      roundSchedule[schedulePtr].fn();
      schedulePtr++;
    }
  }

  // Boss spawns after BOSS_SPAWN_DELAY seconds once the last scheduled wave is fully cleared.
  function updateBossSpawnAfterWaves() {
    if (bossSpawned) return;

    // Only start counting once all scheduled spawns have executed.
    if (schedulePtr < roundSchedule.length) { bossSpawnAt = null; return; }

    // Wait until all regular enemies are cleared (yellow tanks do NOT block boss spawn).
    if (enemies.some(e => e && e.hp > 0 && e.type !== "tank")) { bossSpawnAt = null; return; }

    if (bossSpawnAt == null) bossSpawnAt = roundTime + BOSS_SPAWN_DELAY;

    if (roundTime >= bossSpawnAt) {
      bossSpawned = true;
      bossSpawnAt = null;
      spawnBoss(roundIndex);
    }
  }

  function updatePlayerCore(dt) {
    // movement
    const left = keys.has("arrowleft") || keys.has("a");
    const right = keys.has("arrowright") || keys.has("d");
    const up = keys.has("arrowup") || keys.has("w");
    const down = keys.has("arrowdown") || keys.has("s");

    let dx = (right ? 1 : 0) - (left ? 1 : 0);
    let dy = (down ? 1 : 0) - (up ? 1 : 0);
    if (dx || dy) {
      const len = Math.hypot(dx, dy) || 1;
      dx /= len; dy /= len;
      player.x += dx * player.speed * dt;
      player.y += dy * player.speed * dt;
      player.x = clamp(player.x, 30, W-30);
      player.y = clamp(player.y, 50, H-30);
    }

    // fire
    player.fireCd -= dt;
    if (player.fireCd <= 0) { shootPlayer(); player.fireCd = 0.11; }

    // invuln timer
    if (player.invuln > 0) {
      player.invuln -= dt;
      if (player.invuln <= 0) { player.invuln = 0; player.invulnMode = "none"; }
    }
  }

  function updatePlayerBullets(dt) {
    // bullets
    for (const b of bullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
    bullets = bullets.filter(b => b.y > -60 && b.y < H+60 && b.x > -60 && b.x < W+60);
  }

function update(dt) {
    updateBackground(dt);
    advanceRoundSchedule(dt);
    updateBossSpawnAfterWaves();

    updatePlayerCore(dt);
    updatePlayerBullets(dt);

    // enemies update + shoot + facing
    for (const e of enemies) {
      e.t += dt;

      // face the player
      e.facing = Math.atan2(player.y - e.y, player.x - e.x);

      // Yellow heavy unit (tank): enters from the top, then holds a fixed Y and patrols on X until destroyed
      if (e.type === "tank") {
        // targetY is set at spawn (under the boss' intended position). No teleport / re-anchoring.
        if (e.targetY == null) {
          const estBossY = (roundIndex === 1) ? H*0.16 : H*0.14;
          const estBossH = (roundIndex === 1) ? 160 : 190;
          e.targetY = clamp(estBossY + estBossH/2 + e.r + YELLOW_TANK_UNDER_BOSS_Y_OFFSET, 80, H - 140);
        }

        if (!e.entryDone) {
          const vy = (e.entryVy != null) ? e.entryVy : (e.vy || 180);
          e.y += vy * dt;
          if (e.y >= e.targetY) {
            e.y = e.targetY;
            e.entryDone = true;
            if (e.patrolVx != null) e.vx = e.patrolVx;
          }
        } else {
          e.x += e.vx * dt;
          const minX = e.r + 6;
          const maxX = W - (e.r + 6);
          if (e.x <= minX) { e.x = minX; e.vx = Math.abs(e.vx); }
          if (e.x >= maxX) { e.x = maxX; e.vx = -Math.abs(e.vx); }

          e.shootCd -= dt;
          if (e.shootCd <= 0) {
            spreadAimed(e.x, e.y + 12, 3, getRoundBalance().bulletSpeed.tank, 12);
            e.shootCd = e.baseCd;
          }
        }

        if (e.entryDone) e.y = e.targetY;

        continue;
      }


      if (e.type === "zigzag") e.x += Math.sin(e.t * e.zigFreq) * e.zigAmp * dt;

      // Keep all enemies fully on-screen (prevents unreachable off-screen shooters).
      e.x = clamp(e.x, e.r + 6, W - (e.r + 6));

      if (e.type === "shooter") {
        if (e.y < e.stopY) e.y += e.vy * dt;
        else {
          e.shootCd -= dt;
          if (e.shootCd <= 0) {
            if (roundIndex === 0) spreadAimed(e.x, e.y + 10, 2, getRoundBalance().bulletSpeed.shooter, 8);
            else if (roundIndex === 1) spreadAimed(e.x, e.y + 10, 3, getRoundBalance().bulletSpeed.shooter, 10);
            else spreadAimed(e.x, e.y + 10, 3, getRoundBalance().bulletSpeed.shooter, 10);
            e.shootCd = e.baseCd;
          }
        }
      } else {
        e.y += e.vy * dt;
        e.shootCd -= dt;
        if (e.shootCd <= 0 && e.y > 30) {
          if (e.type === "scout") {
            const sp = getRoundBalance().bulletSpeed.scout;
            const v = aimVec(e.x, e.y + 10, sp);
            pushEnemyBullet(e.x, e.y + 10, v.vx, v.vy, 6);
          } else if (e.type === "zigzag") {
            if (roundIndex === 0) {
              const v = aimVec(e.x, e.y + 10, getRoundBalance().bulletSpeed.zigzag);
              pushEnemyBullet(e.x, e.y + 10, v.vx, v.vy, 6);
            } else if (roundIndex === 1) {
              spreadAimed(e.x, e.y + 10, 2, getRoundBalance().bulletSpeed.zigzag, 10);
            } else {
              spreadAimed(e.x, e.y + 10, 2, getRoundBalance().bulletSpeed.zigzag, 10);
            }
          } else if (e.type === "carrier") {
            spreadAimed(e.x, e.y + 10, 2, getRoundBalance().bulletSpeed.carrier, 10);
          }
          e.shootCd = e.baseCd;
        }
      }
    }
    enemies = enemies.filter(e => e.y < H + 90 && e.hp > 0);

    // boss update
    if (boss && boss.alive) {
      boss.pattern(dt);
      if (boss.entryDone && boss.hp <= 0) {
        boss.alive = false;
        boss = null;
        state = STATE.ROUND_CLEAR;
        sfxExplosion();

        setTimeout(() => {
          if (state !== STATE.ROUND_CLEAR) return;
          roundIndex++;

          if (roundIndex >= 3) {
            openRankingBoard("VICTORY", true);
          } else {
            bullets = []; enemyBullets = []; hazards = []; enemies = []; powerups = []; particles = [];
            nuke = null; shield = null;

            // shield refills each round as before
            player.shieldCharges = 3;

            buildSchedule(roundIndex);
            state = STATE.PLAY;
          }
        }, 900);
      }
    }

    // enemy bullets
    for (const eb of enemyBullets) { eb.x += eb.vx * dt; eb.y += eb.vy * dt; }
    enemyBullets = enemyBullets.filter(eb => eb.x>-90 && eb.x<W+90 && eb.y>-140 && eb.y<H+140);

    // hazards
    for (const hz of hazards) {
      hz.t += dt;

      // Boss laser telegraph tracks player for most of the telegraph, then locks briefly before firing.
      if (hz.kind === "laser" && hz.state === "telegraph") {
        const bossOk = (boss && boss.alive && boss.entryDone);
        if (bossOk) {
          const ox = boss.x + (hz.mOff || 0);
          const oy = boss.y + boss.h * 0.32;

          // Track for ~2.5s of a 3s telegraph, then lock onto the player's position for the last ~0.5s.
          // During the lock window, the target point is fixed, but the beam should still originate from the moving boss,
          // so we recompute the angle each frame toward the fixed target to prevent "free dodges" caused by boss movement.
          const trackDur = Math.max(0, hz.telegraph - 0.5);

          if (hz.t <= trackDur) {
            hz.lockX = null;
            hz.lockY = null;
            hz.ang = Math.atan2(player.y - oy, player.x - ox);
          } else {
            if (hz.lockX == null || hz.lockY == null) {
              hz.lockX = player.x;
              hz.lockY = player.y;
            }
            hz.ang = Math.atan2(hz.lockY - oy, hz.lockX - ox);
          }
        }
      }

      if (hz.state === "telegraph" && hz.t >= hz.telegraph) {
        hz.state = "fire";
        hz.t = 0;
        sfxWarning();
      } else if (hz.state === "fire" && hz.t >= hz.fire) {
        hz.dead = true;
      }
    }
    hazards = hazards.filter(h => !h.dead);

    // powerups
    for (const p of powerups) { p.y += p.vy * dt; p.t += dt; }
    powerups = powerups.filter(p => p.y < H + 50);

    // shield update + block bullets (NULL-safe)
    if (shield) {
      shield.vy += shield.ay * dt;
      shield.y += shield.vy * dt;

      if (shield.y < -80) {
        shield = null;
      } else {
        const y0 = shield.y - shield.h/2;
        const y1 = shield.y + shield.h/2;

        const kept = [];
        for (const eb of enemyBullets) {
          if (eb.y >= y0 - eb.r && eb.y <= y1 + eb.r) {
            popParticles(eb.x, eb.y, 3);
          } else {
            kept.push(eb);
          }
        }
        enemyBullets = kept;
      }
    }

    // nuke update (close -> far)
    if (nuke) {
      nuke.t += dt;

      if (nuke.state === "recede") {
        const u = clamp(nuke.t / nuke.dur, 0, 1);
        nuke.u = u;
        nuke.scale = lerp(nuke.startScale, nuke.endScale, u);
        nuke.x = lerp(nuke.startX, nuke.endX, u);
        nuke.y = lerp(nuke.startY, nuke.endY, u);

        if (u >= 1) {
          nuke.state = "impact";
          nuke.t = 0;
          applyNukeImpact();
        }
      } else if (nuke.state === "impact") {
        if (nuke.t >= 0.28) { nuke.state = "after"; nuke.t = 0; }
      } else {
        if (nuke.t >= 0.35) nuke = null;
      }
    }

    // bullets vs enemies/boss
    let hitForUlt = false;
    for (const b of bullets) {
      for (const e of enemies) {
        if (e.hp <= 0) continue;
        if (circleHit(b.x, b.y, b.r, e.x, e.y, e.hitR ?? e.r)) {
          e.hp -= b.dmg;
          hitForUlt = true;
          b.dead = true;
          if (e.hp <= 0) {
            score += e.points;
            sfxExplosion();
            maybeDropSupplyForEnemy(e);
            popParticles(e.x, e.y, 10);
          }
          break;
        }
      }
      if (b.dead) continue;

      if (boss && boss.alive && boss.entryDone) {
        const rx = boss.x - boss.w/2, ry = boss.y - boss.h/2;
        if (rectCircleHit(rx, ry, boss.w, boss.h, b.x, b.y, b.r)) {
          boss.hp -= b.dmg;
          hitForUlt = true;
          b.dead = true;
          score += 1;
        }
      }
    }
    bullets = bullets.filter(b => !b.dead);

    // Ultimate gauge: charges when your shots hit (time-based amount per hit; independent of weapon/power). Only charges while you don't have a ready ultimate.
    if (hitForUlt && player.ult <= 0) {
      const before = player.ultGauge;
      player.ultGauge = clamp(player.ultGauge + (dt / ULT_FILL_SECONDS), 0, 1);
      if (before < 1 && player.ultGauge >= 1) {
        player.ult = 1;
        player.ultGauge = 1;
        sfxUltReady();
      }
    }

    // player hit checks
    if (player.invuln <= 0) {
      for (const eb of enemyBullets) {
        if (circleHit(player.x, player.y, player.hitR, eb.x, eb.y, eb.r)) { playerHit(); break; }
      }

      if (player.invuln <= 0) {
        for (const hz of hazards) {
          if (hz.state !== "fire") continue;

          if (hz.kind === "wipe") {
            if (hz.mode === "vertical") {
              const safeL = hz.safeX - hz.safeW/2;
              const safeR = hz.safeX + hz.safeW/2;
              if (!(player.x >= safeL && player.x <= safeR)) { playerHit(); break; }
            } else {
              const safeT = hz.safeY - hz.safeH/2;
              const safeB = hz.safeY + hz.safeH/2;
              if (!(player.y >= safeT && player.y <= safeB)) { playerHit(); break; }
            }
          } else if (hz.kind === "laser") {
            const bossOk = (boss && boss.alive && boss.entryDone);
            const ox = bossOk ? (boss.x + (hz.mOff || 0)) : (hz.x0 || W/2);
            const oy = bossOk ? (boss.y + boss.h * 0.32) : (hz.y0 || 0);
            const x1 = ox + Math.cos(hz.ang) * hz.len;
            const y1 = oy + Math.sin(hz.ang) * hz.len;
            const d = distPointToSegment(player.x, player.y, ox, oy, x1, y1);
            if (d <= (player.hitR + (hz.width * 0.5))) { playerHit(); break; }
          }
        }
      }

      if (player.invuln <= 0) {
        for (const e of enemies) {
          if (circleHit(player.x, player.y, player.hitR, e.x, e.y, (e.hitR ?? e.r))) { playerHit(); break; }
        }
      }

      if (player.invuln <= 0 && boss && boss.alive && boss.entryDone) {
        const rx = boss.x - boss.w/2, ry = boss.y - boss.h/2;
        if (rectCircleHit(rx, ry, boss.w, boss.h, player.x, player.y, player.hitR)) playerHit();
      }
    }

    // pickup
    for (const p of powerups) {
      if (circleHit(player.x, player.y, player.r, p.x, p.y, p.r)) {
        p.dead = true;
        if (p.kind === "power") {
          // power max = 6
          player.power = Math.min(6, player.power + 1);
          player.weapon = weaponFromPower(player.power);
          score += 50;
          sfxPower();
        }
      }
    }
    powerups = powerups.filter(p => !p.dead);

    // particles
    for (const pt of particles) {
      pt.t += dt;
      pt.x += pt.vx*dt;
      pt.y += pt.vy*dt;
      pt.vy += 180*dt;
    }
    particles = particles.filter(pt => pt.t < pt.life);

    // performance safety caps
    if (enemyBullets.length > 2500) enemyBullets.length = 2500;
    if (particles.length > 1800) particles.length = 1800;

    if (player.lives <= 0) {
      enterContinue();
    }
  }

  function updateContinue(dt) {
    continueCountdown -= dt;
    if (continueCountdown <= 0) {
      continueCountdown = 0;
      continueNo();
    }
  }

  function playerHit() {
    hitsTaken += 1;
    player.lives -= 1;
    player.invuln = 1.20;
    player.invulnMode = "hit";
    sfxHit();
    popParticles(player.x, player.y, 16);
    enemyBullets = enemyBullets.filter(eb => Math.hypot(eb.x-player.x, eb.y-player.y) > 140);
  }

  function popParticles(x, y, n) {
    for (let i=0;i<n;i++){
      particles.push({ x, y, vx: rand(-220, 220), vy: rand(-220, 120), t:0, life: rand(0.35, 0.70) });
    }
  }

  // ======================
  // Render
  // ======================
  function render() {
    let ox = 0, oy = 0;
    if (shake.t > 0) {
      const denom = (shake.dur > 0 ? shake.dur : 1.0);
      const m = shake.mag * (shake.t / denom);
      ox = rand(-m, m);
      oy = rand(-m, m);
    }

resizeCanvasToDisplaySize();

// Clear in pixel space
ctx.setTransform(1,0,0,1,0,0);
ctx.clearRect(0,0,canvas.width, canvas.height);

// Draw in logical space (W/H), scaled to display size + DPR
applyViewTransform();
ctx.translate(ox, oy);

    drawBackground();
    drawHazards();

    if (shield) drawShield(shield);

    for (const p of powerups) drawSupply(p);
    for (const e of enemies) drawEnemy(e);
    if (boss && boss.alive) drawBoss(boss);

    ctx.fillStyle = "#7bdff2";
    for (const b of bullets) { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); }

    ctx.fillStyle = "#ff6b6b";
    for (const eb of enemyBullets) { ctx.beginPath(); ctx.arc(eb.x, eb.y, eb.r, 0, Math.PI*2); ctx.fill(); }

    ctx.fillStyle = "rgba(255,255,255,0.8)";
    for (const pt of particles) {
      const a = 1 - (pt.t/pt.life);
      ctx.globalAlpha = a;
      ctx.fillRect(pt.x, pt.y, 2, 2);
    }
    ctx.globalAlpha = 1;

    if (nuke) drawNuke(nuke);
    if (nukeFx.t > 0) drawNukeScreenFX();

    drawPlayer();
    drawHUD();

    if (flash.t > 0) {
      ctx.save();
      ctx.globalAlpha = Math.min(0.35, flash.t*2);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-ox, -oy, W, H);
      ctx.restore();
    }

// Overlay should not inherit screen shake, but should stay in logical space
applyViewTransform();
drawOverlayText();
  }

  function drawBackground() {
    ctx.fillStyle = "#070a0f";
    ctx.fillRect(0,0,W,H);

    const starCount = 120;
    ctx.fillStyle = "rgba(200,220,255,0.55)";
    for (let i=0;i<starCount;i++){
      const sx = (i*97) % W;
      const sy = (i*173 + bgY*0.9) % H;
      const r = (i%7===0) ? 2 : 1;
      ctx.fillRect(sx, sy, r, r);
    }

    ctx.fillStyle = "rgba(255,255,255,0.03)";
    for (let y=0;y<H;y+=6) ctx.fillRect(0,y,W,1);
  }

  function drawNukeScreenFX() {
    // Subtle full-screen cue so the ultimate reads as a full-range attack (kept lighter than v22).
    const u = 1 - (nukeFx.t / (nukeFx.dur || 1));
    const maxR = Math.hypot(W, H);

    ctx.save();

    // Quick warm flash across the whole screen
    ctx.globalAlpha = 0.14 * (1 - u);
    ctx.fillStyle = "rgba(255, 230, 200, 1)";
    ctx.fillRect(0, 0, W, H);

    // One soft shock ring (single ring, no stacks)
    ctx.globalCompositeOperation = "lighter";
    const r = u * maxR * 0.90;
    const a = (1 - u) * 0.22;
    if (a > 0.001) {
      ctx.globalAlpha = a;
      ctx.lineWidth = 10;
      ctx.strokeStyle = "rgba(255, 245, 235, 1)";
      ctx.beginPath();
      ctx.arc(W * 0.5, H * 0.5, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Sweeping band wave (reads as a screen-wide strike)
    const y = H * (0.25 + 0.55 * u);
    const hh = 38;
    const g = ctx.createLinearGradient(0, y - hh, 0, y + hh);
    g.addColorStop(0, "rgba(255, 180, 120, 0)");
    g.addColorStop(0.5, "rgba(255, 180, 120, 0.28)");
    g.addColorStop(1, "rgba(255, 180, 120, 0)");
    ctx.globalAlpha = 0.90 * (1 - u);
    ctx.fillStyle = g;
    ctx.fillRect(0, y - hh, W, hh * 2);

    ctx.restore();
  }


  // Player appearance changes per weapon level
  function drawPlayer() {
    if (spritesReady && sprites.player && sprites.player.complete && sprites.player.naturalWidth > 0) {
      drawPlayerSprite();
    } else {
      drawPlayerVector();
    }
  }


  // Weapon upgrade barrel attachments: cylinder + cone.
  // - Tip is placed at each muzzle position so bullets appear to originate from the barrel.
  // - When called from a scaled context, pass that scale as `k` so the barrel stays visually consistent.
  function drawWeaponBarrelsWorld(level, k = 1) {
    if (level < 2) return;

    const muzzles = getMuzzlesForWeapon(level);

    // work in the caller's current local space
    const rLocal = player.r / k;

    const bodyW = Math.max(3, rLocal * 0.22);
    const coneH = Math.max(3, rLocal * 0.22);
    const cylH  = Math.max(5, rLocal * 0.42);

    for (const m of muzzles) {
      const x = (m.x - player.x) / k;
      const yTip = (m.y - player.y) / k;
      drawBarrel(x, yTip, bodyW, cylH, coneH);
    }
  }

  function drawBarrel(x, yTip, w, cylH, coneH) {
    const half = w * 0.5;
    const stroke = Math.max(1, w * 0.14);
    const fill = "rgba(220, 224, 235, 0.95)";     // bright gray
    const outline = "rgba(45, 55, 70, 0.95)";

    ctx.save();
    ctx.translate(x, yTip);

    // Cone (tip at 0,0; base at +coneH)
    ctx.fillStyle = fill;
    ctx.strokeStyle = outline;
    ctx.lineWidth = stroke;

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo( half, coneH);
    ctx.lineTo(-half, coneH);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Cylinder (top at +coneH)
    ctx.beginPath();
    ctx.rect(-half, coneH, w, cylH);
    ctx.fill();
    ctx.stroke();

    // Subtle highlight strip so it reads on dark backgrounds
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.beginPath();
    ctx.rect(-half*0.55, coneH + cylH*0.12, w*0.22, cylH*0.76);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  // Shared player draw helpers (no gameplay change)
  const INVULN_FLICKER_MS = 80;
  function shouldSkipPlayerDraw() {
    return (
      player.invuln > 0 &&
      player.invulnMode === "hit" &&
      (Math.floor(performance.now() / INVULN_FLICKER_MS) % 2 === 0)
    );
  }

  function drawPlayerUltimateRingSprite() {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = 0.50;
    ctx.fillStyle = "rgba(255, 209, 102, 1)";
    ctx.beginPath();
    ctx.arc(0, 0, player.r * 1.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawPlayerSprite() {
    if (shouldSkipPlayerDraw()) return;

    ctx.save();
    ctx.translate(player.x, player.y);
    if (player.invuln > 0 && player.invulnMode === "ultimate") {
      drawPlayerUltimateRingSprite();
    }
// Sprite (provided asset)
    ctx.save();
    ctx.rotate(PLAYER_SPRITE_ROT);

    const { sx, sy, sw, sh } = SPRITE_CROP.player;
    const s = player.r * 2.0;

    // Ensure downscaled sprite looks clean
    ctx.imageSmoothingEnabled = true;
    if ("imageSmoothingQuality" in ctx) ctx.imageSmoothingQuality = "high";

    ctx.drawImage(sprites.player, sx, sy, sw, sh, -s/2, -s/2, s, s);
    ctx.restore();

    // Weapon upgrades: barrel attachments (cylinder + cone)
    drawWeaponBarrelsWorld(player.weapon);

    ctx.restore();
  }

  function drawPlayerVector() {
      if (shouldSkipPlayerDraw()) return;

      const invuln = (player.invuln > 0);
      const bodyColor = invuln
        ? (player.invulnMode === "ultimate" ? "#ffd166" : "#c7f9cc")
        : "#c7f9cc";
      const wingColor = invuln
        ? (player.invulnMode === "ultimate" ? "#ff9f1c" : "#57cc99")
        : "#57cc99";

      ctx.save();
      ctx.translate(player.x, player.y);

      const k = player.r / 18;
      ctx.scale(k, k);

      // base body (Lv1 유지)
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.moveTo(0, -22); ctx.lineTo(16, 18); ctx.lineTo(0, 10); ctx.lineTo(-16, 18);
      ctx.closePath(); ctx.fill();

      // wings
      ctx.fillStyle = wingColor;
      ctx.beginPath(); ctx.moveTo(-20, 10); ctx.lineTo(-4, 6); ctx.lineTo(-10, 20); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(20, 10); ctx.lineTo(4, 6); ctx.lineTo(10, 20); ctx.closePath(); ctx.fill();

      // Lv3: right equipment (adds 3rd stream)
      if (player.weapon >= 3) {
        ctx.fillStyle = "#4ea8de";
        ctx.fillRect(14, -8, 14, 8);
      }

      // Lv4: left equipment (adds 4th stream)
      if (player.weapon >= 4) {
        ctx.fillStyle = "#4ea8de";
        ctx.fillRect(-28, -8, 14, 8);
      }

      // Weapon upgrades: barrel attachments (cylinder + cone)
      drawWeaponBarrelsWorld(player.weapon, k);

      // Hitbox visualization intentionally omitted (player.hitR is used for collisions).
      ctx.restore();
    }


  // Supply crate + parachute
  function drawSupply(p) {
    ctx.save();
    ctx.translate(p.x, p.y);

    const bob = Math.sin(p.t*4) * 3;
    ctx.translate(0, bob);

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "#ffd166";
    ctx.beginPath();
    ctx.arc(0, -22, 18, Math.PI, 0);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-14, -22); ctx.lineTo(-8, -6);
    ctx.moveTo( 14, -22); ctx.lineTo( 8, -6);
    ctx.moveTo(  0, -22); ctx.lineTo( 0, -6);
    ctx.stroke();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#cdb4db";
    ctx.fillRect(-14, -6, 28, 22);
    ctx.strokeStyle = "rgba(0,0,0,0.45)";
    ctx.lineWidth = 2;
    ctx.strokeRect(-14, -6, 28, 22);

    ctx.strokeStyle = "rgba(0,0,0,0.55)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-6, 5); ctx.lineTo(6, 5);
    ctx.moveTo(0, -1); ctx.lineTo(0, 11);
    ctx.stroke();

    ctx.restore();
  }

  // Enemies -> plane-like silhouettes (ROTATE toward player)
  function drawEnemy(e) {
    if (spritesReady && sprites.enemy && sprites.enemy.complete && sprites.enemy.naturalWidth > 0) {
      drawEnemySprite(e);
    } else {
      drawEnemyVector(e);
    }
  }

  function drawEnemySprite(e) {
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.rotate(e.facing + Math.PI/2);

    // Keep the same per-type color spec (tint only)
    let tint = "#a8dadc";
    if (e.type === "shooter") tint = "#90dbf4";
    if (e.type === "zigzag")  tint = "#bdb2ff";
    if (e.type === "tank")    tint = "#ffd6a5";
    if (e.type === "carrier") tint = "#ffadad";

    const r = e.r;

    const src = getTintedEnemy(tint);
    const aspect = SPRITE_CROP.enemy.sw / SPRITE_CROP.enemy.sh;
    const scale = (e.type === "tank") ? (2.0 * 1.08) : 2.0;
    const w = r * scale;
    const h = w / aspect;

    ctx.imageSmoothingEnabled = true;
    if ("imageSmoothingQuality" in ctx) ctx.imageSmoothingQuality = "high";
    ctx.drawImage(src, -w/2, -h/2, w, h);

    // HP bar (screen aligned)
    ctx.rotate(-(e.facing + Math.PI/2));
    const hpRatio = e.hp / e.hpMax;
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(-r, -r-12, r*2, 4);
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillRect(-r, -r-12, r*2*hpRatio, 4);

    ctx.restore();
  }

  function drawEnemyVector(e) {
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.rotate(e.facing + Math.PI/2);

      let body = "#a8dadc", wing = "#6bc0cc", nose = "#ffffff";
      if (e.type === "shooter") { body = "#90dbf4"; wing = "#4ea8de"; }
      if (e.type === "zigzag")  { body = "#bdb2ff"; wing = "#8b7dff"; }
      if (e.type === "tank")    { body = "#ffd6a5"; wing = "#ffb703"; }
      if (e.type === "carrier") { body = "#ffadad"; wing = "#ff5d73"; }

      const r = e.r;

      ctx.fillStyle = body;
      ctx.beginPath();
      ctx.moveTo(0, -r*1.25);
      ctx.lineTo(r*0.78, r*1.08);
      ctx.lineTo(0,  r*0.50);
      ctx.lineTo(-r*0.78, r*1.08);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = wing;
      if (e.type === "tank") {
        ctx.fillRect(-r*1.05, -r*0.10, r*2.10, r*0.45);
      } else if (e.type === "carrier") {
        ctx.fillRect(-r*1.20,  r*0.05, r*2.40, r*0.38);
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(-r*0.95, r*0.55, r*0.40, r*0.45);
        ctx.fillRect( r*0.55, r*0.55, r*0.40, r*0.45);
      } else {
        ctx.beginPath();
        ctx.moveTo(-r*1.10, r*0.15); ctx.lineTo(-r*0.15, r*0.05); ctx.lineTo(-r*0.55, r*0.75);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo( r*1.10, r*0.15); ctx.lineTo( r*0.15, r*0.05); ctx.lineTo( r*0.55, r*0.75);
        ctx.closePath(); ctx.fill();
      }

      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.ellipse(0, -r*0.35, r*0.28, r*0.40, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = nose;
      ctx.beginPath();
      ctx.arc(0, -r*1.05, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // HP bar (screen aligned)
      ctx.rotate(-(e.facing + Math.PI/2));
      const hpRatio = e.hp / e.hpMax;
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(-r, -r-12, r*2, 4);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(-r, -r-12, r*2*hpRatio, 4);

      ctx.restore();
    }


  // Boss -> imposing fortress-ship
  function drawBoss(b) {
    ctx.save();
    ctx.translate(b.x, b.y);

    const w = b.w, h = b.h;

    // Round-based distinct silhouettes (not just recolor)
    if (b.variant === 1) {
      // Iron Mantis: sharp wings + narrow core
      ctx.fillStyle = "#2f343a";
      ctx.beginPath();
      ctx.moveTo(-w*0.50,  h*0.20);
      ctx.lineTo(-w*0.18, -h*0.48);
      ctx.lineTo( 0,      -h*0.30);
      ctx.lineTo( w*0.18, -h*0.48);
      ctx.lineTo( w*0.50,  h*0.20);
      ctx.lineTo( w*0.18,  h*0.44);
      ctx.lineTo(-w*0.18,  h*0.44);
      ctx.closePath();
      ctx.fill();

      // side wing blades
      ctx.fillStyle = "#1f2328";
      ctx.beginPath();
      ctx.moveTo(-w*0.62, 0);
      ctx.lineTo(-w*0.38, -h*0.10);
      ctx.lineTo(-w*0.46,  h*0.28);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo( w*0.62, 0);
      ctx.lineTo( w*0.38, -h*0.10);
      ctx.lineTo( w*0.46,  h*0.28);
      ctx.closePath();
      ctx.fill();

      // core glow
      const coreY = -h*0.10;
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.ellipse(0, coreY, w*0.06, h*0.14, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, coreY, w*0.11, h*0.22, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // vents
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      for (let i=-2;i<=2;i++){
        ctx.fillRect(i*w*0.10 - 8, h*0.18, 16, 6);
      }

      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2;
      ctx.stroke();


    } else if (b.variant === 2) {
      // Storm Railgun: sleek spear cruiser (clean, symmetric silhouette)
      ctx.fillStyle = "#24292f";

      // main hull (elongated spear / diamond)
      ctx.beginPath();
      ctx.moveTo(0,      -h*0.64);
      ctx.lineTo( w*0.44, -h*0.18);
      ctx.lineTo( w*0.30,  h*0.50);
      ctx.lineTo(0,       h*0.62);
      ctx.lineTo(-w*0.30,  h*0.50);
      ctx.lineTo(-w*0.44, -h*0.18);
      ctx.closePath();
      ctx.fill();

      // subtle outline for readability
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // inner armor inset
      ctx.fillStyle = "#2f343a";
      ctx.beginPath();
      ctx.moveTo(0,      -h*0.50);
      ctx.lineTo( w*0.24, -h*0.18);
      ctx.lineTo( w*0.18,  h*0.40);
      ctx.lineTo(0,       h*0.48);
      ctx.lineTo(-w*0.18,  h*0.40);
      ctx.lineTo(-w*0.24, -h*0.18);
      ctx.closePath();
      ctx.fill();

      // side stabilizers (small, clean fins)
      ctx.fillStyle = "#15181c";
      ctx.beginPath();
      ctx.moveTo(-w*0.46,  h*0.10);
      ctx.lineTo(-w*0.62,  h*0.24);
      ctx.lineTo(-w*0.44,  h*0.30);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo( w*0.46,  h*0.10);
      ctx.lineTo( w*0.62,  h*0.24);
      ctx.lineTo( w*0.44,  h*0.30);
      ctx.closePath();
      ctx.fill();

      // central rail spine (barrel)
      ctx.fillStyle = "#353b41";
      ctx.fillRect(-w*0.035, -h*0.08, w*0.07, h*0.78);
      ctx.fillStyle = "#0f1114";
      ctx.fillRect(-w*0.015,  h*0.02, w*0.03, h*0.58);

      // muzzle collar
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(0, h*0.14, w*0.14, h*0.08, 0, 0, Math.PI*2);
      ctx.stroke();

      // panel line accents
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-w*0.18,  h*0.02);
      ctx.lineTo( w*0.18,  h*0.02);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-w*0.14,  h*0.30);
      ctx.lineTo( w*0.14,  h*0.30);
      ctx.stroke();

      // core glow slit (avoid "camera lens" look)
      ctx.save();
      ctx.translate(0, -h*0.18);
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.12, h*0.085, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.18, h*0.125, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

    } else {
      // Abyss Fortress: heavy hull + turrets + spikes
      ctx.fillStyle = "#24292f";
      ctx.beginPath();
      ctx.moveTo(-w*0.52, -h*0.10);
      ctx.lineTo(-w*0.36, -h*0.52);
      ctx.lineTo( w*0.36, -h*0.52);
      ctx.lineTo( w*0.52, -h*0.10);
      ctx.lineTo( w*0.44,  h*0.52);
      ctx.lineTo(-w*0.44,  h*0.52);
      ctx.closePath();
      ctx.fill();

      // upper spikes
      ctx.fillStyle = "#15181c";
      for (let i=-3;i<=3;i++){
        const x = i * (w*0.12);
        ctx.beginPath();
        ctx.moveTo(x, -h*0.52);
        ctx.lineTo(x + 10, -h*0.66);
        ctx.lineTo(x + 20, -h*0.52);
        ctx.closePath();
        ctx.fill();
      }

      // turrets
      ctx.fillStyle = "#353b41";
      const tY = h*0.10;
      for (let i=-2;i<=2;i++){
        const tx = i * (w*0.18);
        ctx.fillRect(tx-18, tY-12, 36, 24);
        ctx.fillRect(tx-6, tY+12, 12, 26);
      }

      // big core
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.ellipse(0, -h*0.08, w*0.10, h*0.16, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, -h*0.08, w*0.18, h*0.26, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // exhaust glow
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#90dbf4";
      ctx.beginPath();
      ctx.ellipse(-w*0.22, h*0.46, w*0.12, h*0.07, 0, 0, Math.PI*2);
      ctx.ellipse( w*0.22, h*0.46, w*0.12, h*0.07, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();
  }

    function drawHazards() {
      for (const hz of hazards) {
        if (hz.kind === "wipe") {
          if (hz.state === "telegraph") {
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = "#ffffff";

            if (hz.mode === "vertical") {
              const safeL = hz.safeX - hz.safeW/2;
              const safeR = hz.safeX + hz.safeW/2;
              ctx.fillRect(0,0, safeL, H);
              ctx.fillRect(safeR,0, W-safeR, H);
              ctx.globalAlpha = 0.45;
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 2;
              ctx.strokeRect(safeL, 0, hz.safeW, H);
            } else {
              const safeT = hz.safeY - hz.safeH/2;
              const safeB = hz.safeY + hz.safeH/2;
              ctx.fillRect(0,0, W, safeT);
              ctx.fillRect(0,safeB, W, H-safeB);
              ctx.globalAlpha = 0.45;
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 2;
              ctx.strokeRect(0, safeT, W, hz.safeH);
            }
            ctx.restore();
          } else if (hz.state === "fire") {
            ctx.save();
            ctx.globalAlpha = 0.40;
            ctx.fillStyle = "#ff4d6d";

            if (hz.mode === "vertical") {
              const safeL = hz.safeX - hz.safeW/2;
              const safeR = hz.safeX + hz.safeW/2;
              ctx.fillRect(0,0, safeL, H);
              ctx.fillRect(safeR,0, W-safeR, H);
            } else {
              const safeT = hz.safeY - hz.safeH/2;
              const safeB = hz.safeY + hz.safeH/2;
              ctx.fillRect(0,0, W, safeT);
              ctx.fillRect(0,safeB, W, H-safeB);
            }
            ctx.restore();
          }
        } else if (hz.kind === "laser") {
          const bossOk = (boss && boss.alive && boss.entryDone);
          const ox = bossOk ? (boss.x + (hz.mOff || 0)) : (hz.x0 || W/2);
          const oy = bossOk ? (boss.y + boss.h * 0.32) : (hz.y0 || 0);
          const x1 = ox + Math.cos(hz.ang) * hz.len;
          const y1 = oy + Math.sin(hz.ang) * hz.len;

          ctx.save();
          if (hz.state === "telegraph") {
            // solid, readable laser preview (not dashed)
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.22;

            // outer glow
            ctx.strokeStyle = "#ff4d6d";
            ctx.lineWidth = hz.width + 10;
            ctx.shadowColor = "#ff4d6d";
            ctx.shadowBlur = 18;

            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(x1, y1);
            ctx.stroke();

            // inner core
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = Math.max(2, hz.width - 2);
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(x1, y1);
            ctx.stroke();

          } else if (hz.state === "fire") {
            ctx.globalAlpha = 0.78;
            ctx.strokeStyle = "#ff4d6d";
            ctx.lineWidth = hz.width + 2;
            ctx.setLineDash([]);
          } else {
            ctx.restore();
            continue;
          }

          if (hz.state !== "telegraph") {
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(x1, y1);
            ctx.stroke();
          }

          ctx.globalAlpha *= 0.65;
          ctx.fillStyle = (hz.state === "fire") ? "#ff4d6d" : "#ffffff";
          ctx.beginPath();
          ctx.arc(ox, oy, 6, 0, Math.PI*2);
          ctx.fill();

          ctx.restore();
        }
      }
    }

  function drawShield(sh) {
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "#90dbf4";
    ctx.fillRect(0, sh.y - sh.h/2, W, sh.h);
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(W/2 - 18, sh.y - sh.h/2, 36, sh.h);
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, sh.y - sh.h/2 + 4, W, 2);
    ctx.restore();
  }

  // Nuke: big near -> small far
  function drawNuke(nk) {
    if (nk.state === "after") return;

    const s = nk.scale;
    const u = nk.u ?? 0;

    ctx.save();

    ctx.globalAlpha = 1;
    ctx.translate(nk.x, nk.y);
    ctx.scale(s, s);

    ctx.fillStyle = "#adb5bd";
    ctx.fillRect(-8, -40, 16, 60);

    ctx.fillStyle = "#6c757d";
    ctx.beginPath();
    ctx.moveTo(-8, -40); ctx.lineTo(0, -58); ctx.lineTo(8, -40);
    ctx.closePath(); ctx.fill();

    ctx.fillStyle = "#ef233c";
    ctx.fillRect(-10, 12, 20, 6);

    ctx.globalAlpha = 0.90 * (1 - u*0.35);
    ctx.fillStyle = "#ffd166";
    ctx.beginPath();
    ctx.moveTo(-6, 20); ctx.lineTo(0, 40 + rand(0,8)); ctx.lineTo(6, 20);
    ctx.closePath(); ctx.fill();

    ctx.restore();

    if (nk.state === "impact") {
      const v = clamp(nk.t / 0.28, 0, 1);
      ctx.save();

      // bomb explosion bloom
      ctx.globalCompositeOperation = "lighter";
      const g = ctx.createRadialGradient(nk.impactX, nk.impactY, 0, nk.impactX, nk.impactY, 260);
      g.addColorStop(0, "rgba(255,209,102,0.35)");
      g.addColorStop(0.35, "rgba(255,77,109,0.20)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.globalAlpha = 0.90 * (1 - v);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(nk.impactX, nk.impactY, 80 + v*220, 0, Math.PI*2);
      ctx.fill();

      // ring shockwave
      ctx.globalCompositeOperation = "source-over";
      ctx.globalAlpha = 0.65 * (1 - v);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(nk.impactX, nk.impactY, 40 + v*180, 0, Math.PI*2);
      ctx.stroke();

      ctx.restore();
    }
  }

  function drawHUD() {
    ctx.save();

    const topH = 62;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(0,0,W,topH);

    // Boss HP bar: keep it at the very top, and move other UI slightly down
    if (boss && boss.alive && boss.entryDone) {
      const barX = 12, barY = 8, barW = W-24, barH = 10;
      const r = boss.hp / boss.hpMax;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = "rgba(255,80,80,0.9)";
      ctx.fillRect(barX, barY, barW * clamp(r,0,1), barH);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.strokeRect(barX, barY, barW, barH);

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "12px system-ui";
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
      ctx.fillText(`BOSS: ${boss.name}`, barX, barY + barH + 4);
    }

    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.font = "bold 14px system-ui";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";
    ctx.fillText(`SCORE ${score}`, 12, 40);

    ctx.textAlign = "right";
    ctx.fillText(`LIVES ${player.lives}  CREDIT ${credits}`, W-12, 40);

    // Ultimate gauge (inside top bar, right side, below score line)
    const ubW = 140, ubH = 8;
    const ubX = W - 12 - ubW;
    const ubY = 52;
    const uRatio = (player.ult > 0) ? 1 : (player.ultGauge || 0);
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(ubX, ubY, ubW, ubH);
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.fillRect(ubX, ubY, ubW * uRatio, ubH);

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "12px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const roundDisp = (state === STATE.VICTORY) ? 3 : Math.min(roundIndex+1, 3);
    ctx.fillText(`ROUND ${roundDisp}/3`, 12, 70);
    ctx.fillText(`WEAPON Lv${player.weapon}  (Power ${player.power}/6)`, 12, 88);
    ctx.fillText(`SHIELD ${player.shieldCharges}/3`, 12, 106);

    ctx.restore();
  }

  function drawOverlayText() {
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    if (state === STATE.TITLE) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 32px system-ui";
      ctx.fillText(GAME_TITLE, W/2, H*0.42);

      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillText("Press 5 to insert credit", W/2, H*0.50);
      ctx.fillText("Press Enter to start", W/2, H*0.54);
      ctx.fillText("K: Key Guide  ·  R: Ranking Board", W/2, H*0.60);

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H*0.84);
      }

    } else if (state === STATE.KEYGUIDE) {
      ctx.fillStyle = "rgba(0,0,0,0.70)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 22px system-ui";
      ctx.fillText("KEY GUIDE", W/2, H*0.28);

      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.88)";
      const lines = [
        "Move: Arrow Keys / WASD",
        "Ultimate: X / Space (2s invincibility)   |   Shield: C / Shift   |   Pause: P",
        "Insert Credit: 5   |   Start: Enter",
        "Continue: Y / N   |   Ranking: R   |   Close Guide: K",
      ];
      for (let i=0;i<lines.length;i++){
        ctx.fillText(lines[i], W/2, H*0.36 + i*24);
      }

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H*0.84);
      }


    } else if (state === STATE.PAUSE) {
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 26px system-ui";
      ctx.fillText("PAUSED", W/2, H/2);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.fillText("Press P to resume", W/2, H/2 + 34);
    } else if (state === STATE.ROUND_CLEAR) {
      ctx.fillStyle = "rgba(0,0,0,0.30)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 26px system-ui";
      ctx.fillText("ROUND CLEAR", W/2, H/2);
    } else if (state === STATE.CONTINUE) {
      ctx.fillStyle = "rgba(0,0,0,0.70)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 30px system-ui";
      ctx.fillText("continue", W/2, H/2 - 40);

      ctx.font = "900 48px system-ui";
      ctx.fillText(String(Math.max(0, Math.ceil(continueCountdown))), W/2, H/2 + 8);

      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillText("Y: YES    N: NO", W/2, H/2 + 56);

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H/2 + 92);
      }


    } else if (state === STATE.RANKING) {
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 28px system-ui";
      ctx.fillText(rankingHeader || "RANKING", W/2, H*0.16);

      // Highlight the current run if it made TOP 10
      let myRank = -1;
      if ((rankingHeader === "GAME OVER" || rankingHeader === "VICTORY") && leaderboardCache && leaderboardCache.length) {
        if (Number.isFinite(lastRunTs) && lastRunTs) myRank = leaderboardCache.findIndex(e => e && e.ts === lastRunTs);
        if (myRank < 0) myRank = leaderboardCache.findIndex(e => e && e.score === lastRunScore && e.hits === lastRunHits);
      }

      // Last run summary (only when arriving from a finished run)
      if (rankingHeader === "GAME OVER" || rankingHeader === "VICTORY") {
        ctx.font = "14px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.88)";
        ctx.fillText(`SCORE: ${lastRunScore}`, W/2, H*0.22);
        ctx.fillText(`Hits Taken: ${lastRunHits}`, W/2, H*0.25);
      }

      const x0 = Math.floor(W * 0.16);
      const y0 = Math.floor(H * 0.34);
      const rowH = 24;

      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "800 14px system-ui";
      ctx.fillText("TOP 10", x0, y0 - 22);

      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "12px system-ui";
      ctx.fillText("RANK", x0, y0);
      ctx.fillText("SCORE", x0 + 70, y0);
      ctx.fillText("HITS", x0 + 190, y0);

      if (!leaderboardCache || leaderboardCache.length === 0) {
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.font = "13px system-ui";
        ctx.fillText("No Records", W/2, y0 + 44);
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.90)";
        ctx.font = "13px system-ui";
        for (let i=0; i<Math.min(10, leaderboardCache.length); i++) {
          const e = leaderboardCache[i];
          const y = y0 + 24 + rowH * i;
          if (i === myRank) {
            ctx.save();
            ctx.fillStyle = "rgba(255,255,255,0.14)";
            ctx.fillRect(x0 - 10, y - rowH/2, Math.floor(W * 0.68), rowH);
            ctx.strokeStyle = "rgba(255,255,255,0.25)";
            ctx.strokeRect(x0 - 10, y - rowH/2, Math.floor(W * 0.68), rowH);
            ctx.restore();
          }
          ctx.fillText(`#${i+1}`, x0, y);
          ctx.fillText(String(e.score), x0 + 70, y);
          ctx.fillText(String(e.hits), x0 + 190, y);
          if (i === myRank) {
            ctx.textAlign = "right";
            ctx.fillStyle = "rgba(255,255,255,0.95)";
            ctx.font = "800 12px system-ui";
            ctx.fillText("YOU", x0 + Math.floor(W * 0.68) - 14, y);
            ctx.textAlign = "left";
            ctx.fillStyle = "rgba(255,255,255,0.90)";
            ctx.font = "13px system-ui";
          }
        }
      }

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "13px system-ui";
      ctx.fillText("Enter: Start (costs 1 credit)  ·  R: Close", W/2, H*0.90);

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H*0.84);
      }

} else if (state === STATE.GAME_OVER) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 28px system-ui";
      ctx.fillText("GAME OVER", W/2, H/2 - 20);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fillText("Press Enter to restart", W/2, H/2 + 20);
      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H/2 + 58);
      }

    } else if (state === STATE.VICTORY) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 28px system-ui";
      ctx.fillText("VICTORY!", W/2, H/2 - 24);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fillText(`Final Score: ${score}`, W/2, H/2 + 12);
      ctx.fillText("Press Enter to restart", W/2, H/2 + 40);
    }

    if (runtimeError) {
      ctx.fillStyle = "rgba(0,0,0,0.78)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 22px system-ui";
      ctx.fillText("RUNTIME ERROR", W/2, H*0.34);

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      const lines = String(runtimeError).split("\n").slice(0, 10);
      let y = H*0.40;
      for (const line of lines) {
        ctx.fillText(line.slice(0, 78), W/2, y);
        y += 16;
      }

      ctx.font = "12px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.fillText("Check the console (F12) for full error details", W/2, y + 22);
    }

    ctx.restore();
  }

  // Start
  initSprites();
  buildSchedule(roundIndex);
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>