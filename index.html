<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>NEON STRIKERS</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; }
    .wrap { height:100%; display:flex; align-items:center; justify-content:center; padding:12px; box-sizing:border-box; }
    canvas { background:#070a0f; border:1px solid #1b2430; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); max-width:min(92vw, 520px); max-height:92vh; width:520px; height:780px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="520" height="780"></canvas>
  </div>

<script>
(() => {
  "use strict";

  const GAME_TITLE = "NEON STRIKERS";

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // ======================
  // Input
  // ======================
  const keys = new Set();
  addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (!e.repeat) {
      // Arcade credits (Key '5', max 9)
      if (k === "5" || e.code === "Numpad5") addCredit();

      // Continue 선택
      if (state === STATE.CONTINUE) {
        if (k === "y") continueYes();
        if (k === "n") continueNo();
      }
      // Key guide
      if (k === "k") {
        if (state === STATE.TITLE) state = STATE.KEYGUIDE;
        else if (state === STATE.KEYGUIDE) state = STATE.TITLE;
        else if (state === STATE.RANKING) state = STATE.KEYGUIDE;
      }

// Ranking board
      if (k === "r") {
        if (state === STATE.TITLE) openRankingBoard("RANKING", false);
        else if (state === STATE.RANKING) state = STATE.TITLE;
        else if (state === STATE.KEYGUIDE) openRankingBoard("RANKING", false);
      }

      if (k === "enter" && state !== STATE.CONTINUE) startOrRestart();
      if (k === "p") togglePause();
      if (k === "x") tryUltimate();
      if (k === "c") tryShield();
    }
    keys.add(k);
    if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(k)) e.preventDefault();
  }, { passive:false });
  addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const lerp  = (a,b,t) => a + (b-a)*t;

  // ======================
  // Runtime Error (freeze-safe overlay)
  // ======================
  let runtimeError = null;

  // ======================
  // Audio (WebAudio SFX)
  // ======================
  const SFX = { ctx:null, enabled:true, shotGate:0 };
  function initAudio() {
    if (SFX.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    SFX.ctx = new AC();
  }
  function tone(freq, dur, vol=0.08, type="square", endFreq=null) {
    if (!SFX.ctx || !SFX.enabled) return;
    const t0 = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const g = SFX.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (endFreq !== null) osc.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), t0 + dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g); g.connect(SFX.ctx.destination);
    osc.start(t0); osc.stop(t0 + dur + 0.02);
  }
  function noise(dur, vol=0.08) {
    if (!SFX.ctx || !SFX.enabled) return;
    const t0 = SFX.ctx.currentTime;
    const bufferSize = Math.floor(SFX.ctx.sampleRate * dur);
    const buffer = SFX.ctx.createBuffer(1, bufferSize, SFX.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2 - 1) * (1 - i/bufferSize);
    const src = SFX.ctx.createBufferSource(); src.buffer = buffer;
    const g = SFX.ctx.createGain();
    g.gain.setValueAtTime(vol, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    src.connect(g); g.connect(SFX.ctx.destination);
    src.start(t0); src.stop(t0 + dur + 0.02);
  }
  function sfxPlayerShot() {
    if (!SFX.ctx || !SFX.enabled) return;
    const now = SFX.ctx.currentTime;
    if (now < SFX.shotGate) return;
    SFX.shotGate = now + 0.07;
    tone(900, 0.03, 0.05, "square", 750);
  }
  function sfxEnemyShot() { if (Math.random() < 0.35) tone(420, 0.05, 0.035, "sawtooth", 260); }
  function sfxExplosion() { noise(0.08, 0.07); tone(180, 0.09, 0.05, "triangle", 60); }
  function sfxPower()     { tone(1200, 0.07, 0.06, "square", 1600); }
  function sfxHit()       { tone(140, 0.12, 0.09, "square", 60); noise(0.05, 0.045); }
  function sfxUltimate()  { tone(220, 0.35, 0.11, "sawtooth", 40); noise(0.25, 0.085); }
  function sfxWarning()   { tone(260, 0.10, 0.05, "square", 520); }
  function sfxShield()    { tone(520, 0.12, 0.07, "triangle", 980); }

  function sfxCoin()      { tone(980, 0.06, 0.06, "square", 1480); tone(1480, 0.06, 0.05, "square", 1960); }
  function sfxNoCredit() { tone(90, 0.12, 0.10, "square", 18); noise(0.06, 0.060); }


  function addCredit() {
    initAudio();
    if (credits >= 9) return;
    credits += 1;
    sfxCoin();
  }

  function enterContinue() {
    if (state === STATE.CONTINUE) return;
    continueCountdown = 5.0;
    state = STATE.CONTINUE;
  }

  function applyWeaponPenaltyOnContinue() {
    // Drop weapon tier by exactly 1 (Lv4→Lv3, Lv3→Lv2, Lv2→Lv1)
    const curWeapon = weaponFromPower(player.power);
    const targetWeapon = Math.max(1, curWeapon - 1);
    const powerMaxByWeapon = { 1:0, 2:2, 3:4, 4:6 };
    const targetPowerMax = powerMaxByWeapon[targetWeapon] ?? 0;
    player.power = Math.min(player.power, targetPowerMax);
    player.weapon = weaponFromPower(player.power);
  }

  function continueYes() {
    if (state !== STATE.CONTINUE) return;

    // If no credit, you can't continue. Give a chance to insert credit.
    if (credits <= 0) {
      noCreditMsg = 1.0;
      sfxNoCredit();
      triggerShake(6, 1.0);
      return;
    }

    credits -= 1;

    // restore lives
    player.lives = 3;

    // refill shield (ultimate gauge preserved on continue)
    player.shieldCharges = 3;

    state = STATE.PLAY;
  }

  function continueNo() {
    if (state !== STATE.CONTINUE) return;
    openRankingBoard("GAME OVER", true);
  }

  // ======================
  // Game State
  // ======================
  const STATE = {TITLE:"TITLE", PLAY:"PLAY", ROUND_CLEAR:"ROUND_CLEAR", CONTINUE:"CONTINUE", GAME_OVER:"GAME_OVER", VICTORY:"VICTORY", PAUSE:"PAUSE", RANKING:"RANKING", KEYGUIDE:"KEYGUIDE" };
  let state = STATE.TITLE;
  let prevState = state;

  // Entities
  let bullets = [];
  let enemies = [];
  let enemyBullets = [];
  let powerups = [];
  let hazards = [];
  let particles = [];
  let boss = null;

  // Ultimate / Shield
  let nuke = null;   // close -> far
  let shield = null; // constant accel upward

  // Progress
  let roundIndex = 0;
  let roundTime = 0;
  let roundSchedule = [];
  let schedulePtr = 0;
  let bossSpawned = false;

  const roundHPMult     = [1.00, 1.22, 1.45];
  const roundBulletMult = [1.00, 1.08, 1.16];

  // Ultimate gauge: fills when you keep hitting enemies (no weapon/power scaling)
  const ULT_FILL_SECONDS = 0.45; // v7: 1/3 charge speed vs v6 (3x slower)



  // FX
  let bgY = 0;
  const flash = { t: 0 };
  const shake = { t: 0, mag: 0, dur: 1.0 };

  const nukeFx = { t: 0, dur: 0.55 }; // screen-wide ultimate impact FX

  function triggerNukeFx() { nukeFx.t = nukeFx.dur; }

  function triggerShake(mag=6, dur=1.0) {
    shake.mag = mag;
    shake.dur = dur;
    shake.t = dur; // refresh (not additive)
  }


  // Score
  let score = 0;


  // Total hits taken (for scoreboard/leaderboard)
  let hitsTaken = 0;

  // Arcade credits (0..9)
  let credits = 0;
  let continueCountdown = 0;
  let noCreditMsg = 0; // seconds

  // ======================
  // Ranking (Top 10, score + hits) - LocalStorage
  // ======================
  const LB_KEY = "neon_strikers_leaderboard_v1";
  let rankingHeader = "RANKING";
  let lastRunScore = 0;
  let lastRunHits  = 0;
  let leaderboardCache = [];

  function loadLeaderboard() {
    try {
      const raw = localStorage.getItem(LB_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      if (!Array.isArray(arr)) return [];
      return arr
        .filter(e => e && Number.isFinite(e.score) && Number.isFinite(e.hits))
        .map(e => ({ score: Math.max(0, e.score|0), hits: Math.max(0, e.hits|0), ts: Number.isFinite(e.ts) ? e.ts : 0 }))
        .slice(0, 10);
    } catch (e) {
      return [];
    }
  }

  function saveLeaderboard(arr) {
    try { localStorage.setItem(LB_KEY, JSON.stringify(arr)); } catch (e) {}
  }

  function recordAndGetLeaderboard(s, h) {
    const arr = loadLeaderboard();
    arr.push({ score: Math.max(0, s|0), hits: Math.max(0, h|0), ts: Date.now() });
    arr.sort((a,b) => (b.score - a.score) || (a.hits - b.hits) || (a.ts - b.ts));
    const top = arr.slice(0, 10);
    saveLeaderboard(top);
    return top;
  }

  function openRankingBoard(header, recordRun) {
    rankingHeader = header || "RANKING";
    if (recordRun) {
      lastRunScore = score|0;
      lastRunHits  = hitsTaken|0;
      leaderboardCache = recordAndGetLeaderboard(lastRunScore, lastRunHits);
    } else {
      leaderboardCache = loadLeaderboard();
    }
    state = STATE.RANKING;
  }


  // Player
  const player = {
    x: W/2,
    y: H*0.80,
    r: 18,
    hitR: 7,
    speed: 350,
    lives: 3,
    invuln: 0,
    invulnMode: "none", // "none"|"hit"|"ultimate"
    weapon: 1,          // 1..4 (max 4)
    power: 0,           // 0..6 (max 6)
    ult: 0,
    ultGauge: 0,
    shieldCharges: 3,
    fireCd: 0,
  };

  // Power 0 → Lv1
  // Power 1~2 → Lv2
  // Power 3~4 → Lv3
  // Power 5~6 → Lv4
  function weaponFromPower(p) {
    if (p >= 5) return 4;
    if (p >= 3) return 3;
    if (p >= 1) return 2;
    return 1;
  }

  function resetAll() {
    bullets = [];
    enemies = [];
    enemyBullets = [];
    powerups = [];
    hazards = [];
    particles = [];
    boss = null;
    nuke = null;
    shield = null;

    score = 0;

    player.x = W/2;
    player.y = H*0.80;
    player.lives = 3;
    player.invuln = 0;
    player.invulnMode = "none";
    player.weapon = 1;
    player.power = 0;
    player.ult = 0;
    player.ultGauge = 0;
    player.shieldCharges = 3;
    player.fireCd = 0;

    roundIndex = 0;
    roundTime = 0;
    schedulePtr = 0;
    bossSpawned = false;
    buildSchedule(roundIndex);

    flash.t = 0;
    shake.t = 0; shake.mag = 0;

    runtimeError = null;
  }

  function startOrRestart() {
    if (state === STATE.PLAY || state === STATE.PAUSE || state === STATE.CONTINUE) return;
    initAudio();

    // Starting/restarting always costs 1 credit
    if (credits <= 0) {
      noCreditMsg = 1.0;
      sfxNoCredit();
      triggerShake(6, 1.0);
      return;
    }

    credits -= 1;
    resetAll();
    state = STATE.PLAY;
  }

  function togglePause() {
    if (state === STATE.PLAY) { prevState = state; state = STATE.PAUSE; }
    else if (state === STATE.PAUSE) { state = prevState || STATE.PLAY; }
  }

  // ======================
  // Schedule
  // ======================
  function buildSchedule(r) {
    roundSchedule = [];
    schedulePtr = 0;
    bossSpawned = false;
    roundTime = 0;

    const add = (t, fn) => roundSchedule.push({ t, fn });

    if (r === 0) {
      add(0.8,  () => spawnLine("scout", 6, 70, 1.05));
      add(2.3,  () => spawnV("scout", 6, 1.05));
      add(4.0,  () => spawnPairShooters(false));
      add(6.3,  () => spawnZigzagPack(5, 1.05));
      add(9.2,  () => spawnCarrier(0.55));
      add(12.2, () => spawnLine("scout", 8, 60, 1.10));
      add(14.8, () => spawnTank(0.50));
      add(17.6, () => spawnZigzagPack(6, 1.08));
      add(20.5, () => spawnCarrier(0.30));
      add(23.0, () => spawnPairShooters(false));
    } else if (r === 1) {
      add(0.8,  () => spawnLine("scout", 8, 60, 1.15));
      add(2.6,  () => spawnPairShooters(true));
      add(5.4,  () => spawnZigzagPack(8, 1.12));
      add(8.4,  () => spawnTank(0.35));
      add(10.7, () => spawnCarrier(0.65));
      add(13.0, () => spawnLine("scout", 10, 54, 1.18));
      add(15.6, () => spawnZigzagPack(9, 1.15));
      add(18.0, () => spawnPairShooters(true));
      add(21.0, () => spawnTank(0.70));
      add(23.3, () => spawnCarrier(0.30));
      add(25.6, () => spawnLine("scout", 12, 50, 1.20));
    } else {
      add(0.8,  () => spawnLine("scout", 10, 54, 1.22));
      add(2.5,  () => spawnPairShooters(true));
      add(4.8,  () => spawnLine("scout", 12, 48, 1.24));
      add(7.0,  () => spawnZigzagPack(11, 1.18));
      add(9.6,  () => spawnTank(0.30));
      add(11.8, () => spawnCarrier(0.60));
      add(14.0, () => spawnPairShooters(true));
      add(16.5, () => spawnZigzagPack(12, 1.20));
      add(19.2, () => spawnLine("scout", 14, 44, 1.28));
      add(21.7, () => spawnTank(0.75));
      add(24.0, () => spawnCarrier(0.30));
      add(26.5, () => spawnPairShooters(true));
    }

    roundSchedule.sort((a,b) => a.t - b.t);
  }

  // ======================
  // Enemies
  // ======================
  const EnemyBase = {
    scout:  { hp: 8,  r: 16, speed: 165, points: 20 },
    shooter:{ hp: 12, r: 18, speed: 115, points: 35 },
    zigzag: { hp: 11, r: 17, speed: 135, points: 30 },
    tank:   { hp: 26, r: 24, speed: 80,  points: 70 },
    carrier:{ hp: 16, r: 20, speed: 100, points: 55 },
  };

  function makeEnemy(type, x, y, extra={}) {
    const base = EnemyBase[type];
    x = clamp(x, base.r + 6, W - (base.r + 6));
    const hpM = roundHPMult[roundIndex] ?? 1;
    const hp = Math.ceil(base.hp * hpM * (extra.hpMult ?? 1));

    const baseCd = ({
      scout: 2.00,
      shooter: 1.55,
      zigzag: 1.75,
      tank: 2.20,
      carrier: 2.30,
    })[type] ?? 2.0;

    const cdMult = (roundIndex === 0) ? 1.00 : (roundIndex === 1 ? 0.95 : 0.90);

    // 드롭 규칙:
    // - carrier는 보급품 100% 드롭
    // - 그 외 유닛은 보급품 드롭 0%
    const dropPower = (type === "carrier") ? 1.0 : 0.0;

    return {
      type,
      x, y,
      vx: extra.vx ?? 0,
      vy: extra.vy ?? base.speed,
      r: base.r,
      hp,
      hpMax: hp,
      t: 0,
      shootCd: extra.shootCd ?? rand(0.45, 1.05),
      baseCd: baseCd * cdMult,
      points: base.points,
      zigAmp: extra.zigAmp ?? 55,
      zigFreq: extra.zigFreq ?? 2.1,
      stopY: extra.stopY ?? rand(H*0.14, H*0.24),
      dropPower,
      facing: Math.PI/2, // toward player each frame
    };
  }

  function spawnLine(type, n, gap, speedMult=1.0) {
    const r = (EnemyBase[type]?.r ?? 18);
    const side = Math.max(40, r + 10);

    let effGap = gap;
    let totalW = (n-1)*effGap;
    const maxSpan = W - 2*side;

    // If the formation would overflow the screen, compress the gap so every unit stays on-screen.
    if (n > 1 && totalW > maxSpan) {
      effGap = maxSpan / (n-1);
      totalW = (n-1)*effGap;
    }

    const startX = clamp((W - totalW)/2, side, W - side - totalW);
    for (let i=0;i<n;i++){
      enemies.push(makeEnemy(type, startX + i*effGap, -30 - i*10, {
        vy: (EnemyBase[type]?.speed ?? 120) * speedMult,
      }));
    }
  }

  function spawnV(type, n, speedMult=1.0) {
    const mid = W/2;
    const spread = 28;
    for (let i=0;i<n;i++){
      const x = mid + (i - (n-1)/2)*spread;
      enemies.push(makeEnemy(type, x, -40 - i*18, { vy: (EnemyBase[type].speed)*speedMult }));
    }
  }

  function spawnPairShooters(denser=false) {
    const left = W*0.28, right = W*0.72;
    enemies.push(makeEnemy("shooter", left,  -30, { stopY: denser ? H*0.18 : H*0.22 }));
    enemies.push(makeEnemy("shooter", right, -70, { stopY: denser ? H*0.18 : H*0.24 }));
    if (denser) enemies.push(makeEnemy("shooter", W*0.50, -110, { stopY: H*0.20 }));
  }

  function spawnZigzagPack(n, speedMult=1.0) {
    for (let i=0;i<n;i++){
      const x = rand(70, W-70);
      enemies.push(makeEnemy("zigzag", x, -40 - i*22, {
        vy: EnemyBase.zigzag.speed * speedMult,
        zigAmp: 55,
        zigFreq: 2.1
      }));
    }
  }

  function spawnTank(xFrac=0.5) {
    enemies.push(makeEnemy("tank", W*xFrac, -40, { vy: EnemyBase.tank.speed }));
  }

  function spawnCarrier(xFrac=0.5) {
    enemies.push(makeEnemy("carrier", W*xFrac, -50, { vy: EnemyBase.carrier.speed }));
  }

  // ======================
  // Aim helpers
  // ======================
  function aimVec(fromX, fromY, speed) {
    let dx = player.x - fromX;
    let dy = player.y - fromY;
    dy = Math.max(dy, 20);
    const len = Math.hypot(dx, dy) || 1;
    return { vx: dx/len * speed, vy: dy/len * speed };
  }

  function spreadAimed(fromX, fromY, count, speed, spreadDeg, src="enemy") {
    let dx = player.x - fromX;
    let dy = player.y - fromY;
    dy = Math.max(dy, 20);
    const base = Math.atan2(dy, dx);

    const m = roundBulletMult[roundIndex] ?? 1;
    const s = speed * m;
    const half = (count-1)/2;

    for (let i=0;i<count;i++){
      const ang = base + (i-half) * (spreadDeg*Math.PI/180);
      pushEnemyBullet(fromX, fromY, Math.cos(ang)*s, Math.sin(ang)*s, 6, src);
    }
  }

  // ======================
  // Bullets / Hazards
  // ======================
  function pushEnemyBullet(x, y, vx, vy, r=6, src="enemy") {
    if (vy < 40) vy = 40;
    enemyBullets.push({ x, y, vx, vy, r, src });
    sfxEnemyShot();
  }

  function spawnScreenWipe(telegraph=3.0, fire=0.55) {
    const mode = (Math.random() < 0.5) ? "vertical" : "horizontal";
    if (mode === "vertical") {
      const safeW = 80;
      const safeX = rand(80, W-80);
      hazards.push({ kind:"wipe", mode, safeX, safeW, state:"telegraph", t:0, telegraph, fire });
    } else {
      const safeH = 80;
      const safeY = rand(H*0.45, H*0.88);
      hazards.push({ kind:"wipe", mode, safeY, safeH, state:"telegraph", t:0, telegraph, fire });
    }
    sfxWarning();
  }

  function spawnBossLaser(telegraph=3.0, countOverride=null) {
    // Laser: show path for 3s (tracks player for most of it), then instant fire.
    // Must originate from boss. Beam count is controlled per-round.
    if (!(boss && boss.alive && boss.entryDone)) return;

    const count = (countOverride === 1 || countOverride === 2)
      ? countOverride
      : ((Math.random() < 0.55) ? 1 : 2);

    const baseY = boss.y + boss.h * 0.32;
    const offsets = (count === 2) ? [-boss.w * 0.18, boss.w * 0.18] : [0];

    for (let i = 0; i < offsets.length; i++) {
      const off = offsets[i];
      const ox = boss.x + off;

      // initial angle; will track player for most of the telegraph in hazard update
      const tx = rand(40, W - 40);
      const ty = rand(H * 0.55, H * 0.92);
      const ang = Math.atan2(ty - baseY, tx - ox);

      hazards.push({
        kind: "laser",
        from: "boss",
        mOff: off,
        ang,
        len: 1400,
        width: 10,
        state: "telegraph",
        t: 0,
        lockX: null,
        lockY: null,
        telegraph,
        fire: 0.20
      });
    }
  }

  // ======================
  // Player shooting (muzzles reflect weapon level)
  // ======================
  function getMuzzlesForWeapon(level) {
    const y = player.y - 22;

    // Lv1: 유지(중앙 1개)
    // Lv2: 앞머리 탄환구 2개 (좌/우)
    // Lv3: 오른쪽 장비 추가 1개
    // Lv4: 왼쪽 장비 추가 1개
    if (level === 1) return [{ x: player.x, y }];
    if (level === 2) return [
      { x: player.x - 7, y },
      { x: player.x + 7, y },
    ];
    if (level === 3) return [
      { x: player.x - 7, y },           // nose L
      { x: player.x + 7, y },           // nose R
      { x: player.x + 22, y: player.y - 6 }, // right equipment
    ];
    return [
      { x: player.x - 7, y },               // nose L
      { x: player.x + 7, y },               // nose R
      { x: player.x + 22, y: player.y - 6 },// right equipment
      { x: player.x - 22, y: player.y - 6 },// left equipment
    ];
  }

  function shootPlayer() {
    const dmg = 2;
    const speed = 650;

    const muzzles = getMuzzlesForWeapon(player.weapon);
    for (const m of muzzles) {
      // straight up (parallel streams), consistent with "줄기"
      const ang = (-90) * Math.PI/180;
      bullets.push({ x: m.x, y: m.y, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, r: 4, dmg });
    }
    sfxPlayerShot();
  }

  // ======================
  // Ultimate: close -> far (bigger near you, then recede)
  // ======================
  function tryUltimate() {
    if (state !== STATE.PLAY) return;
    if (player.ult <= 0) return;
    if (nuke) return;

    player.ult = 0;
    player.ultGauge = 0;

    player.invuln = Math.max(player.invuln, 2.0);
    player.invulnMode = "ultimate";

const startX = player.x;
const startY = clamp(player.y - 30, 80, H - 140);
const endX   = W * 0.5;
const endY   = H * 0.5;
const dur    = 0.75;

nuke = {
  state: "recede",
  x: startX,
  y: startY,
  startX, startY,
  endX, endY,
  t: 0, dur,
  u: 0,

  startScale: 1.95,
  endScale:   0.28,
  scale:      1.95,

  impactX: endX,
  impactY: endY
};

    sfxUltimate();
    flash.t = 0.10;
    // (shake removed per spec)
  }

  function maybeDropSupplyForEnemy(e) {
    if (Math.random() < e.dropPower) {
      powerups.push({ x:e.x, y:e.y, r:12, vy:120, t:0, kind:"power" });
    }
  }

  function applyNukeImpact() {
    // 궁극기 킬도 "탄환 킬과 동일한 드롭 공식" 적용
    // (현재 규칙상 carrier=100%, 나머지=0%)
    for (const e of enemies) {
      score += e.points;
      maybeDropSupplyForEnemy(e);
      popParticles(e.x, e.y, 14);
    }
    enemies = [];

    const bossAlive = (boss && boss.alive && boss.entryDone);

    // 일반 유닛 탄환은 제거. (보스가 존재할 때는 보스 발사 탄환/패턴은 유지)
    if (bossAlive) {
      enemyBullets = enemyBullets.filter(eb => eb.src === "boss");
      // hazards keep (boss patterns must not be canceled)
    } else {
      enemyBullets = [];
      hazards = [];
    }

    shield = null;

    // boss fixed damage
    if (bossAlive) {
      boss.hp -= 220;
      if (boss.hp < 0) boss.hp = 0;
    }


    // Nuke impact FX (global strike feel: main burst + brief screen flash)
    triggerNukeFx();

    const cx = nuke ? nuke.impactX : W/2;
    const cy = nuke ? nuke.impactY : (H * 0.18);

    // main burst (origin) - kept like v21
    for (let i=0;i<90;i++){
      particles.push({ x: cx, y: cy, vx: rand(-520, 520), vy: rand(-520, 520), t:0, life: rand(0.30, 0.85) });
    }

    // very light, screen-wide sparks so it still reads as a full-range attack (toned down vs v22)
    for (let b=0;b<2;b++){
      const bx = rand(70, W - 70);
      const by = rand(H * 0.28, H * 0.85);
      for (let i=0;i<8;i++){
        particles.push({ x: bx, y: by, vx: rand(-220, 220), vy: rand(-220, 220), t:0, life: rand(0.18, 0.40) });
      }
    }

    // slightly stronger shake than v21, but not overwhelming
    triggerShake(9, 0.60);

    flash.t = 0.20;
    sfxExplosion(); sfxExplosion();
  }

  // ======================
  // Shield: constant acceleration upward
  // ======================
  function tryShield() {
    if (state !== STATE.PLAY) return;
    if (player.shieldCharges <= 0) return;
    if (shield) return;

    player.shieldCharges -= 1;

    shield = {
      y: clamp(player.y - 60, 60, H - 120),
      vy: -120,
      ay: -420,
      h: 28
    };

    sfxShield();
    flash.t = 0.06;
  }

  // ======================
  // Bosses
  // ======================
  function spawnBoss(round) {
    if (boss) return;
    boss = (round === 0) ? makeBoss1() : (round === 1) ? makeBoss2() : makeBoss3();
  }

  function makeBossBase(name, hp, w, h, variant) {
    return { name, variant, x: W/2, y: -h, w, h, hp, hpMax: hp, t: 0, phase: 1, alive: true, entryDone: false, vx: 120, atkTimer: 0, wipeCd: 6.0, laserCd: 8.0 };
  }

  function makeBoss1() {
    const b = makeBossBase("Iron Mantis", 1200, 220, 140, 1);
    b.pattern = (dt) => {
      b.t += dt;
      if (!b.entryDone) {
        b.y += 150 * dt;
        if (b.y >= H*0.18) { b.y = H*0.18; b.entryDone = true; b.atkTimer = 0.9; b.wipeCd = 5.0; b.laserCd = 8.5; }
        return;
      }
      b.x += b.vx * dt;
      if (b.x < b.w/2 + 20) { b.x = b.w/2 + 20; b.vx *= -1; }
      if (b.x > W - (b.w/2 + 20)) { b.x = W - (b.w/2 + 20); b.vx *= -1; }

      const r = b.hp / b.hpMax;
      b.phase = (r > 0.60) ? 1 : 2;

      b.wipeCd -= dt;
      if (b.wipeCd <= 0) { spawnScreenWipe(3.0, 0.55); b.wipeCd = (b.phase === 1) ? 8.0 : 7.0; }


      b.atkTimer -= dt;
      if (b.atkTimer <= 0) {
        if (b.phase === 1) { spreadAimed(b.x, b.y + 60, 5, 210, 7, "boss"); b.atkTimer = 0.95; }
        else { spreadAimed(b.x, b.y + 60, 7, 235, 8, "boss"); spreadAimed(b.x, b.y + 60, 3, 260, 12, "boss"); b.atkTimer = 0.85; }
      }
    };
    return b;
  }

  function makeBoss2() {
    const b = makeBossBase("Storm Railgun", 1850, 260, 160, 2);
    b.vx = 135;
    b.pattern = (dt) => {
      b.t += dt;
      if (!b.entryDone) {
        b.y += 160 * dt;
        if (b.y >= H*0.16) { b.y = H*0.16; b.entryDone = true; b.atkTimer = 0.95; b.wipeCd = 5.5; b.laserCd = 8.0; }
        return;
      }

      b.x += b.vx * dt;
      if (b.x < b.w/2 + 10) { b.x = b.w/2 + 10; b.vx *= -1; }
      if (b.x > W - (b.w/2 + 10)) { b.x = W - (b.w/2 + 10); b.vx *= -1; }

      const r = b.hp / b.hpMax;
      b.phase = (r > 0.70) ? 1 : (r > 0.35 ? 2 : 3);

      b.wipeCd -= dt;
      if (b.wipeCd <= 0) { spawnScreenWipe(3.0, 0.55); b.wipeCd = (b.phase === 1) ? 8.0 : (b.phase === 2 ? 7.0 : 6.0); }

      b.laserCd -= dt;
      if (b.laserCd <= 0) { spawnBossLaser(3.0, 1); b.laserCd = (b.phase === 1) ? 8.5 : (b.phase === 2 ? 8.0 : 7.5); }

      b.atkTimer -= dt;
      if (b.atkTimer <= 0) {
        if (b.phase === 1) { spreadAimed(b.x, b.y + 70, 6, 230, 7, "boss"); b.atkTimer = 0.95; }
        else if (b.phase === 2) { spreadAimed(b.x, b.y + 70, 8, 250, 8, "boss"); b.atkTimer = 0.90; }
        else { spreadAimed(b.x, b.y + 70, 10, 265, 8, "boss"); spreadAimed(b.x, b.y + 70, 3, 295, 14, "boss"); b.atkTimer = 0.85; }
      }
    };
    return b;
  }

  function makeBoss3() {
    const b = makeBossBase("Abyss Fortress", 2500, 300, 190, 3);
    b.vx = 150;
    b.pattern = (dt) => {
      b.t += dt;
      if (!b.entryDone) {
        b.y += 180 * dt;
        if (b.y >= H*0.14) { b.y = H*0.14; b.entryDone = true; b.atkTimer = 0.95; b.wipeCd = 5.0; b.laserCd = 7.5; }
        return;
      }

      b.x += b.vx * dt;
      if (b.x < b.w/2 + 8) { b.x = b.w/2 + 8; b.vx *= -1; }
      if (b.x > W - (b.w/2 + 8)) { b.x = W - (b.w/2 + 8); b.vx *= -1; }

      const r = b.hp / b.hpMax;
      b.phase = (r > 0.75) ? 1 : (r > 0.45 ? 2 : (r > 0.15 ? 3 : 4));

      b.wipeCd -= dt;
      if (b.wipeCd <= 0) { spawnScreenWipe(3.0, 0.60); b.wipeCd = (b.phase <= 2) ? 7.0 : (b.phase === 3 ? 6.0 : 5.0); }

      b.laserCd -= dt;
      if (b.laserCd <= 0) { spawnBossLaser(3.0, 2); b.laserCd = (b.phase <= 2) ? 8.0 : (b.phase === 3 ? 7.5 : 7.0); }

      b.atkTimer -= dt;
      if (b.atkTimer <= 0) {
        if (b.phase === 1) { spreadAimed(b.x, b.y + 80, 10, 250, 7, "boss"); b.atkTimer = 0.95; }
        else if (b.phase === 2) { spreadAimed(b.x, b.y + 80, 12, 265, 7, "boss"); spreadAimed(b.x, b.y + 80, 3, 300, 14, "boss"); b.atkTimer = 0.90; }
        else if (b.phase === 3) { spreadAimed(b.x, b.y + 80, 14, 280, 7, "boss"); spreadAimed(b.x, b.y + 80, 5, 320, 12, "boss"); b.atkTimer = 0.85; }
        else { spreadAimed(b.x, b.y + 80, 16, 295, 7, "boss"); spreadAimed(b.x, b.y + 80, 5, 340, 12, "boss"); b.atkTimer = 0.80; }
      }
    };
    return b;
  }

  // ======================
  // Collisions
  // ======================
  function circleHit(ax, ay, ar, bx, by, br) {
    const dx = ax-bx, dy = ay-by;
    return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
  }
  function rectCircleHit(rx, ry, rw, rh, cx, cy, cr) {
    const px = clamp(cx, rx, rx+rw);
    const py = clamp(cy, ry, ry+rh);
    const dx = cx - px, dy = cy - py;
    return dx*dx + dy*dy <= cr*cr;
  }

  function distPointToSegment(px, py, x0, y0, x1, y1) {
    const vx = x1 - x0, vy = y1 - y0;
    const wx = px - x0, wy = py - y0;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px - x0, py - y0);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px - x1, py - y1);
    const b = c1 / c2;
    const bx = x0 + b*vx, by = y0 + b*vy;
    return Math.hypot(px - bx, py - by);
  }


  // ======================
  // Update loop (freeze-safe)
  // ======================
  let last = performance.now();
  function tick(now) {
    requestAnimationFrame(tick);

    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    try {
      if (!runtimeError) {
        // common timers (must tick even on TITLE/GAME_OVER so effects don't get stuck)
        if (flash.t > 0) flash.t = Math.max(0, flash.t - dt);
        if (shake.t > 0) shake.t = Math.max(0, shake.t - dt);
        if (nukeFx.t > 0) nukeFx.t = Math.max(0, nukeFx.t - dt);
        if (noCreditMsg > 0) noCreditMsg = Math.max(0, noCreditMsg - dt);

        if (state === STATE.PLAY) update(dt);
        else if (state === STATE.CONTINUE) updateContinue(dt);
      }
      render();
    } catch (err) {
      runtimeError = (err && err.stack) ? err.stack : String(err);
    }
  }

  function update(dt) {
    bgY += 140 * dt;
    if (bgY > H) bgY -= H;

    roundTime += dt;
    while (schedulePtr < roundSchedule.length && roundTime >= roundSchedule[schedulePtr].t) {
      roundSchedule[schedulePtr].fn();
      schedulePtr++;
    }

    const bossTime = (roundIndex === 0) ? 26.0 : (roundIndex === 1 ? 30.0 : 31.0);
    if (!bossSpawned && roundTime >= bossTime) {
      bossSpawned = true;
      spawnBoss(roundIndex);
    }

    // movement
    const left = keys.has("arrowleft") || keys.has("a");
    const right = keys.has("arrowright") || keys.has("d");
    const up = keys.has("arrowup") || keys.has("w");
    const down = keys.has("arrowdown") || keys.has("s");

    let dx = (right ? 1 : 0) - (left ? 1 : 0);
    let dy = (down ? 1 : 0) - (up ? 1 : 0);
    if (dx || dy) {
      const len = Math.hypot(dx, dy) || 1;
      dx /= len; dy /= len;
      player.x += dx * player.speed * dt;
      player.y += dy * player.speed * dt;
      player.x = clamp(player.x, 30, W-30);
      player.y = clamp(player.y, 50, H-30);
    }

    // fire
    player.fireCd -= dt;
    if (player.fireCd <= 0) { shootPlayer(); player.fireCd = 0.11; }

    // invuln timer
    if (player.invuln > 0) {
      player.invuln -= dt;
      if (player.invuln <= 0) { player.invuln = 0; player.invulnMode = "none"; }
    }

    // bullets
    for (const b of bullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
    bullets = bullets.filter(b => b.y > -60 && b.y < H+60 && b.x > -60 && b.x < W+60);

    // enemies update + shoot + facing
    for (const e of enemies) {
      e.t += dt;

      // face the player
      e.facing = Math.atan2(player.y - e.y, player.x - e.x);

      if (e.type === "zigzag") e.x += Math.sin(e.t * e.zigFreq) * e.zigAmp * dt;

      // Keep all enemies fully on-screen (prevents unreachable off-screen shooters).
      e.x = clamp(e.x, e.r + 6, W - (e.r + 6));

      if (e.type === "shooter") {
        if (e.y < e.stopY) e.y += e.vy * dt;
        else {
          e.shootCd -= dt;
          if (e.shootCd <= 0) {
            if (roundIndex === 0) spreadAimed(e.x, e.y + 10, 2, 210, 8);
            else if (roundIndex === 1) spreadAimed(e.x, e.y + 10, 3, 230, 10);
            else spreadAimed(e.x, e.y + 10, 3, 250, 10);
            e.shootCd = e.baseCd;
          }
        }
      } else {
        e.y += e.vy * dt;
        e.shootCd -= dt;
        if (e.shootCd <= 0 && e.y > 30) {
          if (e.type === "scout") {
            const sp = (roundIndex === 0 ? 195 : (roundIndex === 1 ? 210 : 225));
            const v = aimVec(e.x, e.y + 10, sp);
            pushEnemyBullet(e.x, e.y + 10, v.vx, v.vy, 6);
          } else if (e.type === "zigzag") {
            if (roundIndex === 0) {
              const v = aimVec(e.x, e.y + 10, 205);
              pushEnemyBullet(e.x, e.y + 10, v.vx, v.vy, 6);
            } else if (roundIndex === 1) {
              spreadAimed(e.x, e.y + 10, 2, 230, 10);
            } else {
              spreadAimed(e.x, e.y + 10, 3, 250, 10);
            }
          } else if (e.type === "tank") {
            spreadAimed(e.x, e.y + 12, 3, (roundIndex === 0 ? 210 : (roundIndex === 1 ? 230 : 245)), 12);
          } else if (e.type === "carrier") {
            spreadAimed(e.x, e.y + 10, 2, (roundIndex === 0 ? 210 : (roundIndex === 1 ? 230 : 245)), 10);
          }
          e.shootCd = e.baseCd;
        }
      }
    }
    enemies = enemies.filter(e => e.y < H + 90 && e.hp > 0);

    // boss update
    if (boss && boss.alive) {
      boss.pattern(dt);
      if (boss.entryDone && boss.hp <= 0) {
        boss.alive = false;
        boss = null;
        state = STATE.ROUND_CLEAR;
        sfxExplosion();

        setTimeout(() => {
          if (state !== STATE.ROUND_CLEAR) return;
          roundIndex++;

          if (roundIndex >= 3) {
            openRankingBoard("VICTORY", true);
          } else {
            bullets = []; enemyBullets = []; hazards = []; enemies = []; powerups = []; particles = [];
            nuke = null; shield = null;

            // shield refills each round as before
            player.shieldCharges = 3;

            buildSchedule(roundIndex);
            state = STATE.PLAY;
          }
        }, 900);
      }
    }

    // enemy bullets
    for (const eb of enemyBullets) { eb.x += eb.vx * dt; eb.y += eb.vy * dt; }
    enemyBullets = enemyBullets.filter(eb => eb.x>-90 && eb.x<W+90 && eb.y>-140 && eb.y<H+140);

    // hazards
    for (const hz of hazards) {
      hz.t += dt;

      // Boss laser telegraph tracks player for most of the telegraph, then locks briefly before firing.
      if (hz.kind === "laser" && hz.state === "telegraph") {
        const bossOk = (boss && boss.alive && boss.entryDone);
        if (bossOk) {
          const ox = boss.x + (hz.mOff || 0);
          const oy = boss.y + boss.h * 0.32;

          // Track for ~2.5s of a 3s telegraph, then lock onto the player's position for the last ~0.5s.
          // During the lock window, the target point is fixed, but the beam should still originate from the moving boss,
          // so we recompute the angle each frame toward the fixed target to prevent "free dodges" caused by boss movement.
          const trackDur = Math.max(0, hz.telegraph - 0.5);

          if (hz.t <= trackDur) {
            hz.lockX = null;
            hz.lockY = null;
            hz.ang = Math.atan2(player.y - oy, player.x - ox);
          } else {
            if (hz.lockX == null || hz.lockY == null) {
              hz.lockX = player.x;
              hz.lockY = player.y;
            }
            hz.ang = Math.atan2(hz.lockY - oy, hz.lockX - ox);
          }
        }
      }

      if (hz.state === "telegraph" && hz.t >= hz.telegraph) {
        hz.state = "fire";
        hz.t = 0;
        sfxWarning();
      } else if (hz.state === "fire" && hz.t >= hz.fire) {
        hz.dead = true;
      }
    }
    hazards = hazards.filter(h => !h.dead);

    // powerups
    for (const p of powerups) { p.y += p.vy * dt; p.t += dt; }
    powerups = powerups.filter(p => p.y < H + 50);

    // shield update + block bullets (NULL-safe)
    if (shield) {
      shield.vy += shield.ay * dt;
      shield.y += shield.vy * dt;

      if (shield.y < -80) {
        shield = null;
      } else {
        const y0 = shield.y - shield.h/2;
        const y1 = shield.y + shield.h/2;

        const kept = [];
        for (const eb of enemyBullets) {
          if (eb.y >= y0 - eb.r && eb.y <= y1 + eb.r) {
            popParticles(eb.x, eb.y, 3);
          } else {
            kept.push(eb);
          }
        }
        enemyBullets = kept;
      }
    }

    // nuke update (close -> far)
    if (nuke) {
      nuke.t += dt;

      if (nuke.state === "recede") {
        const u = clamp(nuke.t / nuke.dur, 0, 1);
        nuke.u = u;
        nuke.scale = lerp(nuke.startScale, nuke.endScale, u);
        nuke.x = lerp(nuke.startX, nuke.endX, u);
        nuke.y = lerp(nuke.startY, nuke.endY, u);

        if (u >= 1) {
          nuke.state = "impact";
          nuke.t = 0;
          applyNukeImpact();
        }
      } else if (nuke.state === "impact") {
        if (nuke.t >= 0.28) { nuke.state = "after"; nuke.t = 0; }
      } else {
        if (nuke.t >= 0.35) nuke = null;
      }
    }

    // bullets vs enemies/boss
    let hitForUlt = false;
    for (const b of bullets) {
      for (const e of enemies) {
        if (circleHit(b.x, b.y, b.r, e.x, e.y, e.r)) {
          e.hp -= b.dmg;
          hitForUlt = true;
          b.dead = true;
          if (e.hp <= 0) {
            score += e.points;
            sfxExplosion();
            maybeDropSupplyForEnemy(e);
            popParticles(e.x, e.y, 10);
          }
          break;
        }
      }
      if (b.dead) continue;

      if (boss && boss.alive && boss.entryDone) {
        const rx = boss.x - boss.w/2, ry = boss.y - boss.h/2;
        if (rectCircleHit(rx, ry, boss.w, boss.h, b.x, b.y, b.r)) {
          boss.hp -= b.dmg;
          hitForUlt = true;
          b.dead = true;
          score += 1;
        }
      }
    }
    bullets = bullets.filter(b => !b.dead);

    // Ultimate gauge charge (time-based, independent of weapon/power). Only charges while not holding an ultimate.
    if (hitForUlt && player.ult <= 0) {
      player.ultGauge = clamp(player.ultGauge + (dt / ULT_FILL_SECONDS), 0, 1);
      if (player.ultGauge >= 1) {
        player.ult = 1;
        player.ultGauge = 1;
      }
    }

    // player hit checks
    if (player.invuln <= 0) {
      for (const eb of enemyBullets) {
        if (circleHit(player.x, player.y, player.hitR, eb.x, eb.y, eb.r)) { playerHit(); break; }
      }

      if (player.invuln <= 0) {
        for (const hz of hazards) {
          if (hz.state !== "fire") continue;

          if (hz.kind === "wipe") {
            if (hz.mode === "vertical") {
              const safeL = hz.safeX - hz.safeW/2;
              const safeR = hz.safeX + hz.safeW/2;
              if (!(player.x >= safeL && player.x <= safeR)) { playerHit(); break; }
            } else {
              const safeT = hz.safeY - hz.safeH/2;
              const safeB = hz.safeY + hz.safeH/2;
              if (!(player.y >= safeT && player.y <= safeB)) { playerHit(); break; }
            }
          } else if (hz.kind === "laser") {
            const bossOk = (boss && boss.alive && boss.entryDone);
            const ox = bossOk ? (boss.x + (hz.mOff || 0)) : (hz.x0 || W/2);
            const oy = bossOk ? (boss.y + boss.h * 0.32) : (hz.y0 || 0);
            const x1 = ox + Math.cos(hz.ang) * hz.len;
            const y1 = oy + Math.sin(hz.ang) * hz.len;
            const d = distPointToSegment(player.x, player.y, ox, oy, x1, y1);
            if (d <= (player.hitR + (hz.width * 0.5))) { playerHit(); break; }
          }
        }
      }

      if (player.invuln <= 0) {
        for (const e of enemies) {
          if (circleHit(player.x, player.y, player.hitR, e.x, e.y, e.r * 0.95)) { playerHit(); break; }
        }
      }

      if (player.invuln <= 0 && boss && boss.alive && boss.entryDone) {
        const rx = boss.x - boss.w/2, ry = boss.y - boss.h/2;
        if (rectCircleHit(rx, ry, boss.w, boss.h, player.x, player.y, player.hitR)) playerHit();
      }
    }

    // pickup
    for (const p of powerups) {
      if (circleHit(player.x, player.y, player.r, p.x, p.y, p.r)) {
        p.dead = true;
        if (p.kind === "power") {
          // power max = 6
          player.power = Math.min(6, player.power + 1);
          player.weapon = weaponFromPower(player.power);
          score += 50;
          sfxPower();
        }
      }
    }
    powerups = powerups.filter(p => !p.dead);

    // particles
    for (const pt of particles) {
      pt.t += dt;
      pt.x += pt.vx*dt;
      pt.y += pt.vy*dt;
      pt.vy += 180*dt;
    }
    particles = particles.filter(pt => pt.t < pt.life);

    // performance safety caps
    if (enemyBullets.length > 2500) enemyBullets.length = 2500;
    if (particles.length > 1800) particles.length = 1800;

    if (player.lives <= 0) {
      enterContinue();
    }
  }

  function updateContinue(dt) {
    continueCountdown -= dt;
    if (continueCountdown <= 0) {
      continueCountdown = 0;
      continueNo();
    }
  }

  function playerHit() {
    hitsTaken += 1;
    player.lives -= 1;
    player.invuln = 1.20;
    player.invulnMode = "hit";
    sfxHit();
    popParticles(player.x, player.y, 16);
    enemyBullets = enemyBullets.filter(eb => Math.hypot(eb.x-player.x, eb.y-player.y) > 140);
  }

  function popParticles(x, y, n) {
    for (let i=0;i<n;i++){
      particles.push({ x, y, vx: rand(-220, 220), vy: rand(-220, 120), t:0, life: rand(0.35, 0.70) });
    }
  }

  // ======================
  // Render
  // ======================
  function render() {
    let ox = 0, oy = 0;
    if (shake.t > 0) {
      const denom = (shake.dur > 0 ? shake.dur : 1.0);
      const m = shake.mag * (shake.t / denom);
      ox = rand(-m, m);
      oy = rand(-m, m);
    }

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);
    ctx.translate(ox, oy);

    drawBackground();
    drawHazards();

    if (shield) drawShield(shield);

    for (const p of powerups) drawSupply(p);
    for (const e of enemies) drawEnemy(e);
    if (boss && boss.alive) drawBoss(boss);

    ctx.fillStyle = "#7bdff2";
    for (const b of bullets) { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); }

    ctx.fillStyle = "#ff6b6b";
    for (const eb of enemyBullets) { ctx.beginPath(); ctx.arc(eb.x, eb.y, eb.r, 0, Math.PI*2); ctx.fill(); }

    ctx.fillStyle = "rgba(255,255,255,0.8)";
    for (const pt of particles) {
      const a = 1 - (pt.t/pt.life);
      ctx.globalAlpha = a;
      ctx.fillRect(pt.x, pt.y, 2, 2);
    }
    ctx.globalAlpha = 1;

    if (nuke) drawNuke(nuke);
    if (nukeFx.t > 0) drawNukeScreenFX();

    drawPlayer();
    drawHUD();

    if (flash.t > 0) {
      ctx.save();
      ctx.globalAlpha = Math.min(0.35, flash.t*2);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-ox, -oy, W, H);
      ctx.restore();
    }

    ctx.setTransform(1,0,0,1,0,0);
    drawOverlayText();
  }

  function drawBackground() {
    ctx.fillStyle = "#070a0f";
    ctx.fillRect(0,0,W,H);

    const starCount = 120;
    ctx.fillStyle = "rgba(200,220,255,0.55)";
    for (let i=0;i<starCount;i++){
      const sx = (i*97) % W;
      const sy = (i*173 + bgY*0.9) % H;
      const r = (i%7===0) ? 2 : 1;
      ctx.fillRect(sx, sy, r, r);
    }

    ctx.fillStyle = "rgba(255,255,255,0.03)";
    for (let y=0;y<H;y+=6) ctx.fillRect(0,y,W,1);
  }

  function drawNukeScreenFX() {
    // Subtle full-screen cue so the ultimate reads as a full-range attack (kept lighter than v22).
    const u = 1 - (nukeFx.t / (nukeFx.dur || 1));
    const maxR = Math.hypot(W, H);

    ctx.save();

    // Quick warm flash across the whole screen
    ctx.globalAlpha = 0.14 * (1 - u);
    ctx.fillStyle = "rgba(255, 230, 200, 1)";
    ctx.fillRect(0, 0, W, H);

    // One soft shock ring (single ring, no stacks)
    ctx.globalCompositeOperation = "lighter";
    const r = u * maxR * 0.90;
    const a = (1 - u) * 0.22;
    if (a > 0.001) {
      ctx.globalAlpha = a;
      ctx.lineWidth = 10;
      ctx.strokeStyle = "rgba(255, 245, 235, 1)";
      ctx.beginPath();
      ctx.arc(W * 0.5, H * 0.5, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Sweeping band wave (reads as a screen-wide strike)
    const y = H * (0.25 + 0.55 * u);
    const hh = 38;
    const g = ctx.createLinearGradient(0, y - hh, 0, y + hh);
    g.addColorStop(0, "rgba(255, 180, 120, 0)");
    g.addColorStop(0.5, "rgba(255, 180, 120, 0.28)");
    g.addColorStop(1, "rgba(255, 180, 120, 0)");
    ctx.globalAlpha = 0.90 * (1 - u);
    ctx.fillStyle = g;
    ctx.fillRect(0, y - hh, W, hh * 2);

    ctx.restore();
  }


  // Player appearance changes per weapon level
  function drawPlayer() {
    if (player.invuln > 0 && player.invulnMode === "hit" && Math.floor(performance.now()/80)%2===0) return;

    const invuln = (player.invuln > 0);
    const bodyColor = invuln
      ? (player.invulnMode === "ultimate" ? "#ffd166" : "#c7f9cc")
      : "#c7f9cc";
    const wingColor = invuln
      ? (player.invulnMode === "ultimate" ? "#ff9f1c" : "#57cc99")
      : "#57cc99";

    ctx.save();
    ctx.translate(player.x, player.y);

    // base body (Lv1 유지)
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.moveTo(0, -22); ctx.lineTo(16, 18); ctx.lineTo(0, 10); ctx.lineTo(-16, 18);
    ctx.closePath(); ctx.fill();

    // wings
    ctx.fillStyle = wingColor;
    ctx.beginPath(); ctx.moveTo(-20, 10); ctx.lineTo(-4, 6); ctx.lineTo(-10, 20); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(20, 10); ctx.lineTo(4, 6); ctx.lineTo(10, 20); ctx.closePath(); ctx.fill();

    // Lv2: nose gun ports x2
    if (player.weapon >= 2) {
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.beginPath(); ctx.arc(-6, -16, 2.4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( 6, -16, 2.4, 0, Math.PI*2); ctx.fill();
    }

    // Lv3: right equipment (adds 3rd stream)
    if (player.weapon >= 3) {
      ctx.fillStyle = "#4ea8de";
      ctx.fillRect(14, -8, 14, 8);
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.beginPath(); ctx.arc(26, -6, 2.3, 0, Math.PI*2); ctx.fill();
    }

    // Lv4: left equipment (adds 4th stream)
    if (player.weapon >= 4) {
      ctx.fillStyle = "#4ea8de";
      ctx.fillRect(-28, -8, 14, 8);
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.beginPath(); ctx.arc(-26, -6, 2.3, 0, Math.PI*2); ctx.fill();
    }

    // hitbox hint
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath(); ctx.arc(0, 4, player.hitR, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  // Supply crate + parachute
  function drawSupply(p) {
    ctx.save();
    ctx.translate(p.x, p.y);

    const bob = Math.sin(p.t*4) * 3;
    ctx.translate(0, bob);

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "#ffd166";
    ctx.beginPath();
    ctx.arc(0, -22, 18, Math.PI, 0);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-14, -22); ctx.lineTo(-8, -6);
    ctx.moveTo( 14, -22); ctx.lineTo( 8, -6);
    ctx.moveTo(  0, -22); ctx.lineTo( 0, -6);
    ctx.stroke();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#cdb4db";
    ctx.fillRect(-14, -6, 28, 22);
    ctx.strokeStyle = "rgba(0,0,0,0.45)";
    ctx.lineWidth = 2;
    ctx.strokeRect(-14, -6, 28, 22);

    ctx.strokeStyle = "rgba(0,0,0,0.55)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-6, 5); ctx.lineTo(6, 5);
    ctx.moveTo(0, -1); ctx.lineTo(0, 11);
    ctx.stroke();

    ctx.restore();
  }

  // Enemies -> plane-like silhouettes (ROTATE toward player)
  function drawEnemy(e) {
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.rotate(e.facing + Math.PI/2);

    let body = "#a8dadc", wing = "#6bc0cc", nose = "#ffffff";
    if (e.type === "shooter") { body = "#90dbf4"; wing = "#4ea8de"; }
    if (e.type === "zigzag")  { body = "#bdb2ff"; wing = "#8b7dff"; }
    if (e.type === "tank")    { body = "#ffd6a5"; wing = "#ffb703"; }
    if (e.type === "carrier") { body = "#ffadad"; wing = "#ff5d73"; }

    const r = e.r;

    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.moveTo(0, -r*1.25);
    ctx.lineTo(r*0.78, r*1.08);
    ctx.lineTo(0,  r*0.50);
    ctx.lineTo(-r*0.78, r*1.08);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = wing;
    if (e.type === "tank") {
      ctx.fillRect(-r*1.05, -r*0.10, r*2.10, r*0.45);
    } else if (e.type === "carrier") {
      ctx.fillRect(-r*1.20,  r*0.05, r*2.40, r*0.38);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(-r*0.95, r*0.55, r*0.40, r*0.45);
      ctx.fillRect( r*0.55, r*0.55, r*0.40, r*0.45);
    } else {
      ctx.beginPath();
      ctx.moveTo(-r*1.10, r*0.15); ctx.lineTo(-r*0.15, r*0.05); ctx.lineTo(-r*0.55, r*0.75);
      ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo( r*1.10, r*0.15); ctx.lineTo( r*0.15, r*0.05); ctx.lineTo( r*0.55, r*0.75);
      ctx.closePath(); ctx.fill();
    }

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(0, -r*0.35, r*0.28, r*0.40, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = nose;
    ctx.beginPath();
    ctx.arc(0, -r*1.05, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // HP bar (screen aligned)
    ctx.rotate(-(e.facing + Math.PI/2));
    const hpRatio = e.hp / e.hpMax;
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(-r, -r-12, r*2, 4);
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillRect(-r, -r-12, r*2*hpRatio, 4);

    ctx.restore();
  }

  // Boss -> imposing fortress-ship
  function drawBoss(b) {
    ctx.save();
    ctx.translate(b.x, b.y);

    const w = b.w, h = b.h;

    // Round-based distinct silhouettes (not just recolor)
    if (b.variant === 1) {
      // Iron Mantis: sharp wings + narrow core
      ctx.fillStyle = "#2f343a";
      ctx.beginPath();
      ctx.moveTo(-w*0.50,  h*0.20);
      ctx.lineTo(-w*0.18, -h*0.48);
      ctx.lineTo( 0,      -h*0.30);
      ctx.lineTo( w*0.18, -h*0.48);
      ctx.lineTo( w*0.50,  h*0.20);
      ctx.lineTo( w*0.18,  h*0.44);
      ctx.lineTo(-w*0.18,  h*0.44);
      ctx.closePath();
      ctx.fill();

      // side wing blades
      ctx.fillStyle = "#1f2328";
      ctx.beginPath();
      ctx.moveTo(-w*0.62, 0);
      ctx.lineTo(-w*0.38, -h*0.10);
      ctx.lineTo(-w*0.46,  h*0.28);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo( w*0.62, 0);
      ctx.lineTo( w*0.38, -h*0.10);
      ctx.lineTo( w*0.46,  h*0.28);
      ctx.closePath();
      ctx.fill();

      // core glow
      const coreY = -h*0.10;
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.ellipse(0, coreY, w*0.06, h*0.14, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, coreY, w*0.11, h*0.22, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // vents
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      for (let i=-2;i<=2;i++){
        ctx.fillRect(i*w*0.10 - 8, h*0.18, 16, 6);
      }

      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2;
      ctx.stroke();

    
    } else if (b.variant === 2) {
      // Storm Railgun: sleek spear cruiser (clean, symmetric silhouette)
      ctx.fillStyle = "#24292f";

      // main hull (elongated spear / diamond)
      ctx.beginPath();
      ctx.moveTo(0,      -h*0.64);
      ctx.lineTo( w*0.44, -h*0.18);
      ctx.lineTo( w*0.30,  h*0.50);
      ctx.lineTo(0,       h*0.62);
      ctx.lineTo(-w*0.30,  h*0.50);
      ctx.lineTo(-w*0.44, -h*0.18);
      ctx.closePath();
      ctx.fill();

      // subtle outline for readability
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // inner armor inset
      ctx.fillStyle = "#2f343a";
      ctx.beginPath();
      ctx.moveTo(0,      -h*0.50);
      ctx.lineTo( w*0.24, -h*0.18);
      ctx.lineTo( w*0.18,  h*0.40);
      ctx.lineTo(0,       h*0.48);
      ctx.lineTo(-w*0.18,  h*0.40);
      ctx.lineTo(-w*0.24, -h*0.18);
      ctx.closePath();
      ctx.fill();

      // side stabilizers (small, clean fins)
      ctx.fillStyle = "#15181c";
      ctx.beginPath();
      ctx.moveTo(-w*0.46,  h*0.10);
      ctx.lineTo(-w*0.62,  h*0.24);
      ctx.lineTo(-w*0.44,  h*0.30);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo( w*0.46,  h*0.10);
      ctx.lineTo( w*0.62,  h*0.24);
      ctx.lineTo( w*0.44,  h*0.30);
      ctx.closePath();
      ctx.fill();

      // central rail spine (barrel)
      ctx.fillStyle = "#353b41";
      ctx.fillRect(-w*0.035, -h*0.08, w*0.07, h*0.78);
      ctx.fillStyle = "#0f1114";
      ctx.fillRect(-w*0.015,  h*0.02, w*0.03, h*0.58);

      // muzzle collar
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(0, h*0.14, w*0.14, h*0.08, 0, 0, Math.PI*2);
      ctx.stroke();

      // panel line accents
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-w*0.18, -h*0.02);
      ctx.lineTo( w*0.18, -h*0.06);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-w*0.14,  h*0.26);
      ctx.lineTo( w*0.14,  h*0.22);
      ctx.stroke();

      // core glow slit (avoid "camera lens" look)
      ctx.save();
      ctx.translate(0, -h*0.12);
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.14, h*0.045, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.22, h*0.075, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

    } else {
      // Abyss Fortress: heavy hull + turrets + spikes
      ctx.fillStyle = "#24292f";
      ctx.beginPath();
      ctx.moveTo(-w*0.52, -h*0.10);
      ctx.lineTo(-w*0.36, -h*0.52);
      ctx.lineTo( w*0.36, -h*0.52);
      ctx.lineTo( w*0.52, -h*0.10);
      ctx.lineTo( w*0.44,  h*0.52);
      ctx.lineTo(-w*0.44,  h*0.52);
      ctx.closePath();
      ctx.fill();

      // upper spikes
      ctx.fillStyle = "#15181c";
      for (let i=-3;i<=3;i++){
        const x = i * (w*0.12);
        ctx.beginPath();
        ctx.moveTo(x, -h*0.52);
        ctx.lineTo(x + 10, -h*0.66);
        ctx.lineTo(x + 20, -h*0.52);
        ctx.closePath();
        ctx.fill();
      }

      // turrets
      ctx.fillStyle = "#353b41";
      const tY = h*0.10;
      for (let i=-2;i<=2;i++){
        const tx = i * (w*0.18);
        ctx.fillRect(tx-18, tY-12, 36, 24);
        ctx.fillRect(tx-6, tY+12, 12, 26);
      }

      // big core
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.ellipse(0, -h*0.08, w*0.10, h*0.16, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, -h*0.08, w*0.18, h*0.26, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // exhaust glow
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#90dbf4";
      ctx.beginPath();
      ctx.ellipse(-w*0.22, h*0.46, w*0.12, h*0.07, 0, 0, Math.PI*2);
      ctx.ellipse( w*0.22, h*0.46, w*0.12, h*0.07, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();
  }

    function drawHazards() {
      for (const hz of hazards) {
        if (hz.kind === "wipe") {
          if (hz.state === "telegraph") {
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = "#ffffff";

            if (hz.mode === "vertical") {
              const safeL = hz.safeX - hz.safeW/2;
              const safeR = hz.safeX + hz.safeW/2;
              ctx.fillRect(0,0, safeL, H);
              ctx.fillRect(safeR,0, W-safeR, H);
              ctx.globalAlpha = 0.45;
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 2;
              ctx.strokeRect(safeL, 0, hz.safeW, H);
            } else {
              const safeT = hz.safeY - hz.safeH/2;
              const safeB = hz.safeY + hz.safeH/2;
              ctx.fillRect(0,0, W, safeT);
              ctx.fillRect(0,safeB, W, H-safeB);
              ctx.globalAlpha = 0.45;
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 2;
              ctx.strokeRect(0, safeT, W, hz.safeH);
            }
            ctx.restore();
          } else if (hz.state === "fire") {
            ctx.save();
            ctx.globalAlpha = 0.40;
            ctx.fillStyle = "#ff4d6d";

            if (hz.mode === "vertical") {
              const safeL = hz.safeX - hz.safeW/2;
              const safeR = hz.safeX + hz.safeW/2;
              ctx.fillRect(0,0, safeL, H);
              ctx.fillRect(safeR,0, W-safeR, H);
            } else {
              const safeT = hz.safeY - hz.safeH/2;
              const safeB = hz.safeY + hz.safeH/2;
              ctx.fillRect(0,0, W, safeT);
              ctx.fillRect(0,safeB, W, H-safeB);
            }
            ctx.restore();
          }
        } else if (hz.kind === "laser") {
          const bossOk = (boss && boss.alive && boss.entryDone);
          const ox = bossOk ? (boss.x + (hz.mOff || 0)) : (hz.x0 || W/2);
          const oy = bossOk ? (boss.y + boss.h * 0.32) : (hz.y0 || 0);
          const x1 = ox + Math.cos(hz.ang) * hz.len;
          const y1 = oy + Math.sin(hz.ang) * hz.len;

          ctx.save();
          if (hz.state === "telegraph") {
            // solid, readable laser preview (not dashed)
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.22;

            // outer glow
            ctx.strokeStyle = "#ff4d6d";
            ctx.lineWidth = hz.width + 10;
            ctx.shadowColor = "#ff4d6d";
            ctx.shadowBlur = 18;

            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(x1, y1);
            ctx.stroke();

            // inner core
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = Math.max(2, hz.width - 2);
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(x1, y1);
            ctx.stroke();

          } else if (hz.state === "fire") {
            ctx.globalAlpha = 0.78;
            ctx.strokeStyle = "#ff4d6d";
            ctx.lineWidth = hz.width + 2;
            ctx.setLineDash([]);
          } else {
            ctx.restore();
            continue;
          }

          if (hz.state !== "telegraph") {
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(x1, y1);
            ctx.stroke();
          }

          ctx.globalAlpha *= 0.65;
          ctx.fillStyle = (hz.state === "fire") ? "#ff4d6d" : "#ffffff";
          ctx.beginPath();
          ctx.arc(ox, oy, 6, 0, Math.PI*2);
          ctx.fill();

          ctx.restore();
        }
      }
    }

  function drawShield(sh) {
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "#90dbf4";
    ctx.fillRect(0, sh.y - sh.h/2, W, sh.h);
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(W/2 - 18, sh.y - sh.h/2, 36, sh.h);
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, sh.y - sh.h/2 + 4, W, 2);
    ctx.restore();
  }

  // Nuke: big near -> small far
  function drawNuke(nk) {
    if (nk.state === "after") return;

    const s = nk.scale;
    const u = nk.u ?? 0;

    ctx.save();

    const shadowR = 26 + (s * 26);
    ctx.globalAlpha = 0.22 * (1 - u);
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(nk.x, nk.y + 80, shadowR*1.1, shadowR*0.45, 0, 0, Math.PI*2);
    ctx.fill();

    if (nk.state === "recede") {
      ctx.globalAlpha = 0.12 * (1 - u);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      for (let i=0;i<6;i++){
        const ang = (-Math.PI/2) + (i-2.5)*0.18;
        const len = 80 + (1 - u) * 160;
        ctx.beginPath();
        ctx.moveTo(nk.x + Math.cos(ang)*8, nk.y + Math.sin(ang)*8);
        ctx.lineTo(nk.x - Math.cos(ang)*len, nk.y - Math.sin(ang)*len);
        ctx.stroke();
      }
    }

    ctx.globalAlpha = 1;
    ctx.translate(nk.x, nk.y);
    ctx.scale(s, s);

    ctx.fillStyle = "#adb5bd";
    ctx.fillRect(-8, -40, 16, 60);

    ctx.fillStyle = "#6c757d";
    ctx.beginPath();
    ctx.moveTo(-8, -40); ctx.lineTo(0, -58); ctx.lineTo(8, -40);
    ctx.closePath(); ctx.fill();

    ctx.fillStyle = "#ef233c";
    ctx.fillRect(-10, 12, 20, 6);

    ctx.globalAlpha = 0.90 * (1 - u*0.35);
    ctx.fillStyle = "#ffd166";
    ctx.beginPath();
    ctx.moveTo(-6, 20); ctx.lineTo(0, 40 + rand(0,8)); ctx.lineTo(6, 20);
    ctx.closePath(); ctx.fill();

    ctx.restore();

    if (nk.state === "impact") {
      const v = clamp(nk.t / 0.28, 0, 1);
      ctx.save();

      // bomb explosion bloom
      ctx.globalCompositeOperation = "lighter";
      const g = ctx.createRadialGradient(nk.impactX, nk.impactY, 0, nk.impactX, nk.impactY, 260);
      g.addColorStop(0, "rgba(255,209,102,0.35)");
      g.addColorStop(0.35, "rgba(255,77,109,0.20)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.globalAlpha = 0.90 * (1 - v);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(nk.impactX, nk.impactY, 80 + v*220, 0, Math.PI*2);
      ctx.fill();

      // ring shockwave
      ctx.globalCompositeOperation = "source-over";
      ctx.globalAlpha = 0.65 * (1 - v);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(nk.impactX, nk.impactY, 40 + v*180, 0, Math.PI*2);
      ctx.stroke();

      ctx.restore();
    }
  }

  function drawHUD() {
    ctx.save();

    const topH = 62;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(0,0,W,topH);

    // Boss HP bar: keep it at the very top, and move other UI slightly down
    if (boss && boss.alive && boss.entryDone) {
      const barX = 12, barY = 8, barW = W-24, barH = 10;
      const r = boss.hp / boss.hpMax;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = "rgba(255,80,80,0.9)";
      ctx.fillRect(barX, barY, barW * clamp(r,0,1), barH);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.strokeRect(barX, barY, barW, barH);

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "12px system-ui";
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
      ctx.fillText(`BOSS: ${boss.name}`, barX, barY + barH + 4);
    }

    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.font = "bold 14px system-ui";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";
    ctx.fillText(`SCORE ${score}`, 12, 40);

    ctx.textAlign = "right";
    ctx.fillText(`LIVES ${player.lives}  CREDIT ${credits}`, W-12, 40);

    // Ultimate gauge (inside top bar, right side, below score line)
    const ubW = 140, ubH = 8;
    const ubX = W - 12 - ubW;
    const ubY = 52;
    const uRatio = (player.ult > 0) ? 1 : (player.ultGauge || 0);
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(ubX, ubY, ubW, ubH);
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.fillRect(ubX, ubY, ubW * uRatio, ubH);

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "12px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const roundDisp = (state === STATE.VICTORY) ? 3 : Math.min(roundIndex+1, 3);
    ctx.fillText(`ROUND ${roundDisp}/3`, 12, 70);
    ctx.fillText(`WEAPON Lv${player.weapon}  (Power ${player.power}/6)`, 12, 88);
    ctx.fillText(`SHIELD ${player.shieldCharges}/3`, 12, 106);

    ctx.restore();
  }

  function drawOverlayText() {
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    if (state === STATE.TITLE) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 32px system-ui";
      ctx.fillText(GAME_TITLE, W/2, H*0.42);

      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillText("Press 5 to insert credit", W/2, H*0.50);
      ctx.fillText("Press Enter to start", W/2, H*0.54);
      ctx.fillText("K: Key Guide  ·  R: Ranking Board", W/2, H*0.60);

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H*0.84);
      }

    } else if (state === STATE.KEYGUIDE) {
      ctx.fillStyle = "rgba(0,0,0,0.70)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 22px system-ui";
      ctx.fillText("KEY GUIDE", W/2, H*0.28);

      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.88)";
      const lines = [
        "Move: Arrow Keys / WASD",
        "Ultimate: X (2s invincibility)   |   Shield: C   |   Pause: P",
        "Insert Credit: 5   |   Start: Enter",
        "Continue: Y / N   |   Ranking: R   |   Close Guide: K",
      ];
      for (let i=0;i<lines.length;i++){
        ctx.fillText(lines[i], W/2, H*0.36 + i*24);
      }

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H*0.84);
      }


    } else if (state === STATE.PAUSE) {
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 26px system-ui";
      ctx.fillText("PAUSED", W/2, H/2);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.fillText("Press P to resume", W/2, H/2 + 34);
    } else if (state === STATE.ROUND_CLEAR) {
      ctx.fillStyle = "rgba(0,0,0,0.30)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 26px system-ui";
      ctx.fillText("ROUND CLEAR", W/2, H/2);
    } else if (state === STATE.CONTINUE) {
      ctx.fillStyle = "rgba(0,0,0,0.70)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 30px system-ui";
      ctx.fillText("continue", W/2, H/2 - 40);

      ctx.font = "900 48px system-ui";
      ctx.fillText(String(Math.max(0, Math.ceil(continueCountdown))), W/2, H/2 + 8);

      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillText("Y: YES    N: NO", W/2, H/2 + 56);

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H/2 + 92);
      }

    
    } else if (state === STATE.RANKING) {
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 28px system-ui";
      ctx.fillText(rankingHeader || "RANKING", W/2, H*0.16);

      // Last run summary (only when arriving from a finished run)
      if (rankingHeader === "GAME OVER" || rankingHeader === "VICTORY") {
        ctx.font = "14px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.88)";
        ctx.fillText(`SCORE: ${lastRunScore}`, W/2, H*0.22);
        ctx.fillText(`Hits Taken: ${lastRunHits}`, W/2, H*0.25);
      }

      const x0 = Math.floor(W * 0.16);
      const y0 = Math.floor(H * 0.34);
      const rowH = 24;

      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "800 14px system-ui";
      ctx.fillText("TOP 10", x0, y0 - 22);

      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "12px system-ui";
      ctx.fillText("RANK", x0, y0);
      ctx.fillText("SCORE", x0 + 70, y0);
      ctx.fillText("HITS", x0 + 190, y0);

      if (!leaderboardCache || leaderboardCache.length === 0) {
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.font = "13px system-ui";
        ctx.fillText("No Records", W/2, y0 + 44);
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.90)";
        ctx.font = "13px system-ui";
        for (let i=0; i<Math.min(10, leaderboardCache.length); i++) {
          const e = leaderboardCache[i];
          const y = y0 + 24 + rowH * i;
          ctx.fillText(`#${i+1}`, x0, y);
          ctx.fillText(String(e.score), x0 + 70, y);
          ctx.fillText(String(e.hits), x0 + 190, y);
        }
      }

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "13px system-ui";
      ctx.fillText("Enter: Start (costs 1 credit)  ·  R: Close", W/2, H*0.90);

      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H*0.84);
      }

} else if (state === STATE.GAME_OVER) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 28px system-ui";
      ctx.fillText("GAME OVER", W/2, H/2 - 20);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fillText("Press Enter to restart", W/2, H/2 + 20);
      if (noCreditMsg > 0) {
        ctx.font = "800 18px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("INSERT CREDIT (5)", W/2, H/2 + 58);
      }

    } else if (state === STATE.VICTORY) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 28px system-ui";
      ctx.fillText("VICTORY!", W/2, H/2 - 24);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fillText(`Final Score: ${score}`, W/2, H/2 + 12);
      ctx.fillText("Press Enter to restart", W/2, H/2 + 40);
    }

    if (runtimeError) {
      ctx.fillStyle = "rgba(0,0,0,0.78)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 22px system-ui";
      ctx.fillText("RUNTIME ERROR", W/2, H*0.34);

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      const lines = String(runtimeError).split("\n").slice(0, 10);
      let y = H*0.40;
      for (const line of lines) {
        ctx.fillText(line.slice(0, 78), W/2, y);
        y += 16;
      }

      ctx.font = "12px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.fillText("Check the console (F12) for full error details", W/2, y + 22);
    }

    ctx.restore();
  }

  // Start
  buildSchedule(roundIndex);
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>